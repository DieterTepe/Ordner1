<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modbus RTU über WebUSB</title>
        <!-- Einbinden der externen Bibliothek (Chart.js als Beispiel) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Einfügen direkt nach dem öffnenden <head>-Tag -->

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background: linear-gradient(to bottom right, darkblue, lightblue);
            color: white;
        }
        h1 {
            font-size: 1.5em;
            margin: 20px 0;
        }
        div {
            width: 90%;
            max-width: 600px;
            margin-bottom: 20px;
        }
        label, select, button, input {
            font-size: 1em;
            margin: 5px 0;
            width: 100%;
            border-radius: 10px; /* Abgerundete Ecken */
            padding: 10px;
            box-sizing: border-box;
        }
        select:hover {
              background-color: black;
color: white;
font-weight: bold;
              transform: scale(1.05); /* Vergrößerung bei Hover */
              box-shadow: 0 8px 10px rgba(0, 0, 0, 0.15); /* Verstärkte Schattierung bei Hover */
           }
          input:hover {
              background-color: black;
color: white;
font-weight: bold;
              transform: scale(1.05); /* Vergrößerung bei Hover */
              box-shadow: 0 8px 10px rgba(0, 0, 0, 0.15); /* Verstärkte Schattierung bei Hover */
           }
        button {
             background-color: #007BFF;
             color: white;
             max-width: 600px;; /* Anpassbare Breite */
             height: 40px; /* Angepasste Höhe */
             border-radius: 15px; /* Abgerundete Ecken */
             box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 3D-Schattierung */
             transition: transform 0.2s, box-shadow 0.2s; /* Animationseffekte */
             cursor: pointer;
             display: flex; /* Flexbox aktivieren */
             align-items: center; /* Vertikale Zentrierung */
             justify-content: center; /* Horizontale Zentrierung */
          }
           button:hover {
              background-color: #0056b3;
              transform: scale(1.05); /* Vergrößerung bei Hover */
              box-shadow: 0 8px 10px rgba(0, 0, 0, 0.15); /* Verstärkte Schattierung bei Hover */
           }
          #logBox {
            width: 100%;
            height: 150px;
            background-color: white;
            border-radius: 5px; /* Abgerundete Ecken */
            color: black;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            overflow-y: scroll;
            white-space: pre-wrap;
        }
        #infoBox {
            background-color: #f9f9f9;
            color: #333;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            width: 90%;
            max-width: 600px;
            box-sizing: border-box;
        }
        #resultsBox {
            background-color: #f9f9f9;
            color: #333;
            padding: 5px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            width: 90%;
            max-width: 600px;
            box-sizing: border-box;
        }
        .led-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            margin-bottom: 15px;
        }
        .led {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            position: absolute;
            top: 15px;
            right: 10px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
        }
        .led.red {
            background: radial-gradient(circle, red 0%, darkred 70%);
        }
        .led.green {
            background: radial-gradient(circle, lime 0%, green 70%);
        }
        .led.yellow {
            background: radial-gradient(circle, yellow 0%, goldenrod 70%);
        }
        #channelDataBox {
            width: 90%;
            max-width: 600px;
            overflow-x: auto;
        }
        #channelDataBox table {
            width: 100%;
            border-collapse: collapse;
        }
        #channelDataBox th, #channelDataBox td {
            border: 1px solid #ccc;
            padding: 4px;
            font-size: 0.86em;
            text-align: left;
        }
        #channelDataBox th {
            background-color: #007BFF;
            color: white;
        }
        .LED_Ladezustand {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: red; /* Standardfarbe */
            position: absolute; /* Ermöglicht die Positionierung an jeder Stelle */
            top: 23px; /* Beispielpositionierung */
            left: 20px; /* Beispielpositionierung */
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        .blink {
            animation: blink 2s infinite; /* Blinkrhythmus alle 2 Sekunden */
        }
    </style>
</head>
<body>
    <h1>Modbus RTU über WebUSB</h1>
    <div id="infoBox">
        <h2>Empfohlene Einstellungen:</h2>
        <p>
            Registeradresse: <strong>4x1000 bis 4x1007</strong> (für Kanal 1 bis 8).<br>
            Modusbereiche:<br>
            0: 0 bis 5V<br>
            1: 1 bis 5V<br>
            2: 0 bis 20mA<br>
            3: 4 bis 20mA<br>
            4: 4096-Skala-Codemodus
        </p>
    </div>
    <div id="resultsBox">
        <h2>Aktuelle Kanaldaten:</h2>
        <pre id="channelDataBox">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>K</th>
                        <th>Modus</th>
                        <th>Roh</th>
                        <th>Eing. Spann.</th>
                        <th>Eing. Strom</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>n.v</td>
                        <td>0</td>
                        <td>0.00000 Volt</td>
                        <td>0.0000 mA</td>
                    </tr>
                </tbody>
            </table>
        </pre>
    </div>
    <div class="led-container">
        <button id="connectUSBButton">USB verbinden</button>
        <div id="usbLed" class="led red"></div>
    </div>
    <div class="led-container">
        <button id="toggleDriverButton">Auto-Modus Eingänge aktiv/deaktiv</button>
        <div id="driverLed" class="led red"></div>
    </div>
    <div class="led-container">
        <button id="toggleDebugButton">Debug Modus</button>
        <div id="debugLed" class="led red"></div>
    </div>
    <div>
        <label for="channelSelect">Kanal auswählen:</label>
        <select id="channelSelect">
            <option value="1">Kanal 1</option>
            <option value="2">Kanal 2</option>
            <option value="3">Kanal 3</option>
            <option value="4">Kanal 4</option>
            <option value="5">Kanal 5</option>
            <option value="6">Kanal 6</option>
            <option value="7">Kanal 7</option>
            <option value="8">Kanal 8</option>
        </select>
        <button id="readRegisterButton">Register Modus auslesen</button>
    </div>
    <div>
        <label for="modeSelect">Modus auswählen:</label>
        <select id="modeSelect">
            <option value="0">0 bis 5V</option>
            <option value="1">1 bis 5V</option>
            <option value="2">0 bis 20mA</option>
            <option value="3">4 bis 20mA</option>
            <option value="4">4096-Skala-Codemodus</option>
        </select>
        <button id="writeRegisterButton">Register Modus schreiben</button>
    </div>
    <div>
        <label for="readIntervalInput">Zeittakt zum Auslesen festlegen (1-300 Sek):</label>
        <input 
            type="number" 
            id="readIntervalInput" 
            min="1" 
            max="300" 
            value="10">
    </div>
    <div>
        <label for="baudRateSelect">Baudrate wählen:</label>
        <select id="baudRateSelect">
            <option value="4800">4800</option>
            <option value="9600" selected>9600</option>
            <option value="19200">19200</option>
            <option value="38400">38400</option>
            <option value="57600">57600</option>
        </select>
        <label for="paritySelect">Parität wählen:</label>
        <select id="paritySelect">
            <option value="none" selected>Keine</option>
            <option value="even">Gerade</option>
            <option value="odd">Ungerade</option>
        </select>
        <label for="stopBitsSelect">Stopbits wählen:</label>
        <select id="stopBitsSelect">
            <option value="1">1</option>
            <option value="2" selected>2</option>
        </select>
        <button id="setSerialConfigButton">Serielle Konfiguration setzen</button>
    </div>
    <div>
        <button id="readAllChannelsButton">Alle Eingänge auslesen</button>
    </div>
    <div>
        <h2>Logbox</h2>
        <textarea id="logBox" readonly></textarea><br>
        <button id="clearLog">Log leeren</button>
    </div>
    
   <!-- Platzierung der LED im HTML -->
    <div class="LED_Ladezustand"></div> <!-- Einfügen vor dem schließenden </body>-Tag -->

    <script>
        // Konstanten für Selektoren und Konfigurationsdaten
        const SELECTORS = {
            connectUSBButton: '#connectUSBButton',
            toggleDriverButton: '#toggleDriverButton',
            toggleDebugButton: '#toggleDebugButton',
            usbLed: '#usbLed',
            driverLed: '#driverLed',
            debugLed: '#debugLed',
            logBox: '#logBox',
            clearLog: '#clearLog',
            channelSelect: '#channelSelect',
            modeSelect: '#modeSelect',
            baudRateSelect: '#baudRateSelect',
            paritySelect: '#paritySelect',
            stopBitsSelect: '#stopBitsSelect',
            setSerialConfigButton: '#setSerialConfigButton',
            readAllChannelsButton: '#readAllChannelsButton',
            readRegisterButton: '#readRegisterButton',
            writeRegisterButton: '#writeRegisterButton',
            readIntervalInput: '#readIntervalInput', // Neue Zeittakt-Eingabe
            channelDataBox: '#channelDataBox'
        };

// Globale Variablen
let usbDevice; // USB-Gerät, das mit WebUSB verbunden ist
let modbusDevice; // Modbus-Gerät, das die Kommunikation verwaltet

// Serielle Konfigurationsparameter
let currentBaudRate = 9600; // Standard-Baudrate für die serielle Kommunikation
let currentParity = 'none'; // Standard-Parität: Keine
let currentStopBits = 2; // Standard-Stopbits: 2 (laut Handbuch)

// Statusvariablen
let debugEnabled = false; // Status des Debug-Modus: Aktiviert oder deaktiviert
let driverEnabled = false; // Status des Auto-Modus: Aktiviert oder deaktiviert
let usbConnected = false; // Status der USB-Verbindung: Verbunden oder nicht

// Kanaldaten
// let channelDataa = Array(8).fill({ mode: "Unbekannt", raw: 0, voltage: 0, current: 0 }); 
// Array zur Speicherung der Kanaldaten (Modus, Rohdaten, Spannung, Strom)
let globalRawData = Array(8).fill(0); 
// Array zur Speicherung der Rohdaten aller Kanäle
let globalModeData = Array(8).fill("Unbekannt"); 
// Array zur Speicherung der Modi aller Kanäle

// Auto-Modus und Intervallsteuerung
let readInterval = 10000; // Standardzeit für den Auto-Modus-Takt (in Millisekunden, 10 Sekunden)
let periodicReadId = null; // ID des Intervalls für den Auto-Modus (wird von setInterval verwendet)

        // Hinzufügen zusätzlicher globaler Variablen
        let ledBlinkInterval; // Intervall für das Blinken der LED

// NEUE VARIABLE HINZUFÜGEN:
// Diese Variable wird benötigt, um die Daten für alle Kanäle zu speichern.
let channelDataa = [
    { mode: 'Auto', raw: '10', voltage: 3.3, current: 0.5 },
    { mode: 'Manual', raw: '20', voltage: 5.0, current: 1.0 },
    { mode: 'Auto', raw: '30', voltage: 12.0, current: 0.2 },
    { mode: 'Manual', raw: '40', voltage: 3.0, current: 0.8 },
    { mode: 'Auto', raw: '50', voltage: 5.5, current: 1.1 },
    { mode: 'Manual', raw: '60', voltage: 4.0, current: 0.6 },
    { mode: 'Auto', raw: '70', voltage: 6.0, current: 1.3 },
    { mode: 'Manual', raw: '80', voltage: 7.0, current: 1.4 }
];



// Sonstige Variablen
// (Wenn weitere Variablen hinzugefügt wurden, sollten sie hier ergänzt werden)

        // Funktion zum Hinzufügen von Nachrichten in die Logbox
        function logMessage(message, type = 'info') {
            const logBox = document.querySelector(SELECTORS.logBox);
            const prefix = type === 'error' ? '[FEHLER]' : type === 'debug' ? '[DEBUG]' : '[INFO]';
            if (type === 'debug' && !debugEnabled) return; // Nur Debug-Nachrichten filtern
            logBox.value += `${prefix} ${message}\n`;
            logBox.scrollTop = logBox.scrollHeight;
            console[type === 'error' ? 'error' : 'log'](message);
        }

 // NEUE FUNKTION HINZUFÜGEN:
// Diese Funktion aktualisiert den LED-Status basierend auf den Daten und dem Seitenstatus.
function updateLedStatus() {
    const led = document.querySelector('.LED_Ladezustand');
    if (!led) {
        console.error("LED-Element (.LED_Ladezustand) nicht gefunden.");
        return;
    }

    const secondPageLoaded = localStorage.getItem('secondPageLoaded');
    const dataWithTimestamp = JSON.parse(localStorage.getItem('tableData'));
    const currentTime = Date.now();

    if (!secondPageLoaded || secondPageLoaded !== 'true') {
        // Empfänger-Seite ist nicht aktiv
        led.style.backgroundColor = 'red';
        led.classList.remove('blink');
        clearInterval(ledBlinkInterval);
        logMessage("[INFO] Empfänger-Seite nicht aktiv.", "info");
    } else if (dataWithTimestamp && (currentTime - dataWithTimestamp.timestamp) <= 5 * 60 * 60 * 1000) {
        // Daten sind aktuell und Empfänger ist aktiv
        clearInterval(ledBlinkInterval);
        let isGreen = true;
        ledBlinkInterval = setInterval(() => {
            led.style.backgroundColor = isGreen ? 'green' : 'yellow';
            isGreen = !isGreen;
        }, 2000);
        led.classList.add('blink');
        logMessage("[INFO] Daten aktuell und Empfänger-Seite aktiv.", "info");
    } else {
        // Daten sind veraltet
        led.style.backgroundColor = 'yellow';
        led.classList.remove('blink');
        clearInterval(ledBlinkInterval);
        logMessage("[WARNUNG] Daten sind älter als 5 Stunden.", "warning");
    }
}


// NEUE FUNKTION HINZUFÜGEN:
// Diese Funktion speichert die Tabellendaten und den Zeitstempel in den `localStorage`.
// Berechnung einer einfachen Prüfsumme (hier CRC32, aber dies könnte angepasst werden)
function calculateChecksum(data) {
    let checksum = 0;
    for (let i = 0; i < data.length; i++) {
        checksum = (checksum + data.charCodeAt(i)) % 65535;
    }
    return checksum;
}

function saveTableDataToLocalStorage() {
    try {
        // Tabellendaten vorbereiten
        const tableData = channelDataa.map(data => ({
            mode: data.mode,
            raw: data.raw,
            voltage: data.voltage.toFixed(5),
            current: data.current.toFixed(5)
        }));
        const timestamp = Date.now(); // Aktuellen Zeitstempel hinzufügen

        // Daten in einen JSON-String umwandeln
        const dataString = JSON.stringify(tableData);
        
        // Prüfsumme berechnen
        const checksum = calculateChecksum(dataString);

        // Daten mit Zeitstempel und Prüfsumme im LocalStorage speichern
        const dataWithTimestampAndChecksum = {
            tableData,
            timestamp,
            checksum
        };

        // Speichern in LocalStorage
        localStorage.setItem('tableData', JSON.stringify(dataWithTimestampAndChecksum));
        localStorage.setItem('firstPageLoaded', 'true'); // Status der Seite speichern

        // Optional: Log-Meldung hinzufügen (falls Logbox vorhanden)
        const logBox = document.getElementById('logBox');
        if (logBox) {
            logBox.innerText += `[INFO] Daten erfolgreich gespeichert.\n`;
        }
    } catch (error) {
        // Fehlerbehandlung bei Problemen mit LocalStorage
        console.error("Fehler beim Speichern der Daten:", error.message);
    }
}


// NEUES INTERVALL HINZUFÜGEN:
// Diese Zeile startet die Funktion `saveTableDataToLocalStorage()` jede Sekunde.
setInterval(saveTableDataToLocalStorage, 1000);
saveTableDataToLocalStorage();
updateLedStatus();

    

// Funktion zum Starten des periodischen Auslesens
function startPeriodicRead() {
    if (driverEnabled) {
        if (periodicReadId) {
            clearInterval(periodicReadId); // Vorhandenes Intervall beenden
        }

        // Direktes Auslösen der "Alle Eingänge auslesen"-Funktion
        periodicReadId = setInterval(async () => {
            logMessage("Auto-Modus: Lese Register für alle Kanäle..."); // Log-Nachricht
            for (let i = 0; i < 8; i++) {
                await modbusDevice.readRegister(0x1000 + i); // Alle Register auslesen
            }
            logMessage("Auto-Modus: Berechne und lese alle Eingänge..."); // Log-Nachricht
            await modbusDevice.readInputs(); // Alle Eingänge auslesen
            updateChannelDataBox(); // Kanaldatenanzeige aktualisieren
logBox.value = ''; 
        }, readInterval);

        logMessage(`Periodisches Auslesen gestartet. Intervall: ${readInterval / 1000} Sekunden.`);
    }
}

// Funktion zum Stoppen des periodischen Auslesens
function stopPeriodicRead() {
    if (periodicReadId) { // Prüfen, ob ein Intervall aktiv ist
        clearInterval(periodicReadId); // Intervall stoppen
        periodicReadId = null; // Intervall-ID zurücksetzen, um Konflikte zu vermeiden

        // Log-Nachricht ausgeben, um anzuzeigen, dass das periodische Auslesen gestoppt wurde
        logMessage("Periodisches Auslesen gestoppt.");
    }
}

    // Funktion zur Aktualisierung des LED-Status
    function updateLed(ledElement, isActive) {
        clearInterval(ledElement.blinkInterval);  // Vorherige Blinkintervalle löschen
        if (isActive) {
            let ledOn = false;
            ledElement.blinkInterval = setInterval(() => {
                ledElement.className = ledOn ? 'led green' : 'led yellow';  // Zwischen grün und gelb wechseln
                ledOn = !ledOn;
            }, 2000);  // Intervallzeit auf 2 Sekunden setzen
        } else {
            ledElement.className = 'led red';  // LED auf rot setzen, wenn inaktiv
        }
    }

// Funktion zur Aktualisierung der Anzeige der Kanaldaten
function updateChannelDataBox() {
    const tableBody = document.querySelector('#dataTable tbody');  // Tabellenkörper selektieren
    tableBody.innerHTML = '';  // Tabelleninhalt leeren

    // Durch alle Kanaldaten iterieren und Tabellenreihen erzeugen
    channelDataa.forEach((data, index) => {
        const row = document.createElement('tr');  // Neue Tabellenreihe erstellen

        // Zellen für jede Spalte erstellen
        const cellChannel = document.createElement('td');
        cellChannel.textContent = (index + 1).toString();
        row.appendChild(cellChannel);

        const cellMode = document.createElement('td');
        cellMode.textContent = data.mode;
        row.appendChild(cellMode);

        const cellRaw = document.createElement('td');
        cellRaw.textContent = data.raw.toString();
        row.appendChild(cellRaw);

        const cellVoltage = document.createElement('td');
        cellVoltage.textContent = data.voltage.toFixed(5) + ' Volt';
        row.appendChild(cellVoltage);

        const cellCurrent = document.createElement('td');
        if (data.mode === "4096-Skala" && data.current > 0) {
            cellCurrent.textContent = data.current.toFixed(5) + ' mA';
        } else {
            cellCurrent.textContent = (data.mode.includes('mA') && data.current > 0) ? data.current.toFixed(5) + ' mA' : '0.00000 mA';
        }
        row.appendChild(cellCurrent);

        tableBody.appendChild(row);  // Neue Reihe zur Tabelle hinzufügen
    });
}

// Funktion, die eine Aktion mit Timeout ausführt
    async function withTimeout(promise, timeout) {
        return Promise.race([
            promise,  // Der ursprüngliche Promise
            new Promise((_, reject) => setTimeout(() => reject(new Error('Zeitüberschreitung')), timeout))  // Der Timeout-Promise
        ]);
    }

    // Objekt zur Verwaltung der Modbus-Operationen
    const modbusOperations = (() => {
        // Klasse, die ein Modbus-Gerät repräsentiert
        class ModbusDevice {
            constructor(device) {
                this.device = device;  // Das verbundene USB-Gerät
                this.endpointOut = 2;  // Out-Endpoint für das Gerät
                this.endpointIn = 1;  // In-Endpoint für das Gerät
                this.timeout = 5000;  // Timeout für die Operationen (in ms)

                // Buffer zur Speicherung der Register-Lesedaten, Register-Schreibdaten und Analog-Eingangsdaten
                this.registerReadBuffer = [];
                this.registerWriteBuffer = [];
                this.analogInputBuffer = [];
            }

            // Methode zum Senden eines Modbus-Kommandos
            async sendCommand(command) {
                const crc = calculateCRC(command);  // CRC für das Kommando berechnen
                const request = new Uint8Array([...command, crc & 0xFF, (crc >> 8) & 0xFF]);  // Request-Paket erstellen
                await withTimeout(this.device.transferOut(this.endpointOut, request), this.timeout);  // Paket senden
                logMessage(`DEBUG: Gesendetes Paket: ${Array.from(request).map(b => b.toString(16).padStart(2, '0')).join(' ')}`, 'debug');  // Log-Nachricht ausgeben
            }

            // Methode zum Empfangen einer Antwort vom Modbus-Gerät
            async receiveResponse(bufferName) {
                this[bufferName] = [];  // Den entsprechenden Buffer leeren
                try {
                    const result = await withTimeout(this.device.transferIn(this.endpointIn, 64), this.timeout);  // Antwort empfangen
                    const receivedData = new Uint8Array(result.data.buffer);  // Empfangene Daten in ein Uint8Array konvertieren
                    this[bufferName].push(...receivedData);  // Empfangene Daten in den Buffer einfügen
                    logMessage(`DEBUG: Empfangenes Paket (Rohdaten): ${Array.from(receivedData).map(b => b.toString(16).padStart(2, '0')).join(' ')}`, 'debug');  // Log-Nachricht ausgeben
                    return receivedData;  // Empfangene Daten zurückgeben
                } catch (error) {
                    logMessage(`Fehler beim Empfangen: ${error.message}`, 'error');  // Fehler loggen
                    return null;  // Null zurückgeben im Fehlerfall
                }
            }

// Methode zum Lesen eines Registers
        async readRegister(address) {
            logMessage(`Lese Register ${address.toString(16)}...`);  // Log-Nachricht über den Lesevorgang
            this.registerReadBuffer = [];  // Buffer leeren
            const command = [0x01, 0x03, address >> 8, address & 0xFF, 0x00, 0x01];  // Kommando für das Lesen des Registers
            await this.sendCommand(command);  // Kommando senden

            await new Promise(resolve => setTimeout(resolve, 40));  // Kurze Verzögerung

            const response = await this.receiveResponse('registerReadBuffer');  // Antwort empfangen
            if (response && response.length >= 7) {
                const filteredResponse = response.slice(-7);  // Antwort bereinigen
                logMessage(`DEBUG: Bereinigte Antwort: ${Array.from(filteredResponse).map(b => b.toString(16).padStart(2, '0')).join(' ')}`, 'debug');  // Log-Nachricht ausgeben

                const mode = filteredResponse[4];  // Modus aus der Antwort extrahieren
                const modeDescription = ["0 bis 5V", "1 bis 5V", "0 bis 20mA", "4 bis 20mA", "4096-Skala"][mode] || "Unbekannter Modus";  // Modusbeschreibung bestimmen
                const channel = (address - 0x1000) + 1;  // Kanalnummer berechnen
                logMessage(`Register gelesen: Kanal ${channel}, Modus ${modeDescription}`);  // Log-Nachricht über das gelesene Register

                channelDataa[channel - 1] = { mode: modeDescription, raw: 0, voltage: 0, current: 0 };  // Kanaldaten aktualisieren
                globalModeData[channel - 1] = modeDescription;  // Globale Modusdaten aktualisieren
            } else {
                logMessage("Fehlerhafte Antwortlänge oder ungültige Daten erhalten.", "error");  // Fehler loggen
            }
        }

// Methode zum Schreiben in ein Register
async writeRegister(address, mode) {
    logMessage(`Schreibe Modus ${mode} in Register ${address.toString(16)}...`);  // Log-Nachricht über den Schreibvorgang
    this.registerWriteBuffer = [];  // Buffer leeren
    const command = [0x01, 0x06, address >> 8, address & 0xFF, 0x00, mode];  // Kommando für das Schreiben des Registers
    await this.sendCommand(command);  // Kommando senden

    await new Promise(resolve => setTimeout(resolve, 100));  // Kurze Verzögerung

    const response = await this.receiveResponse('registerReadBuffer');  // Antwort empfangen
    if (response && response.length >= 8) {
        const filteredResponse = response.slice(-8);  // Antwort bereinigen
        logMessage(`DEBUG: Bereinigte Antwort: ${Array.from(filteredResponse).map(b => b.toString(16).padStart(2, '0')).join(' ')}`, 'debug');  // Log-Nachricht ausgeben

        const mode = filteredResponse[5];  // Modus aus der Antwort extrahieren
        const modeDescription = ["0 bis 5V", "1 bis 5V", "0 bis 20mA", "4 bis 20mA", "4096-Skala"][mode] || "Unbekannter Modus";  // Modusbeschreibung bestimmen
        const channel = (address - 0x1000) + 1;  // Kanalnummer berechnen
        logMessage(`Register gelesen: Kanal ${channel}, Modus ${modeDescription}`);  // Log-Nachricht über das gelesene Register

        channelDataa[channel - 1] = { mode: modeDescription, raw: 0, voltage: 0, current: 0 };  // Kanaldaten aktualisieren
        globalModeData[channel - 1] = modeDescription;  // Globale Modusdaten aktualisieren
    } else {
        logMessage("Fehlerhafte Antwortlänge oder ungültige Daten erhalten.", "error");  // Fehler loggen
    }
}

        // Methode zum Lesen aller Eingänge
        async readInputs() {
            logMessage("Lese alle Eingänge...");  // Log-Nachricht über den Lesevorgang
            const command = [0x01, 0x04, 0x00, 0x00, 0x00, 0x08];  // Kommando für das Lesen der Eingänge
            await this.sendCommand(command);  // Kommando senden
            await new Promise(resolve => setTimeout(resolve, 40));  // Kurze Verzögerung

            const response = await this.receiveResponse('analogInputBuffer');  // Antwort empfangen
            if (response && response.length >= 19) {
                const filteredResponse = response.slice(2);  // Antwort bereinigen
                logMessage(`DEBUG: Bereinigte Antwort: ${Array.from(filteredResponse).map(b => b.toString(16).padStart(2, '0')).join(' ')}`, 'debug');  // Log-Nachricht ausgeben

                for (let i = 0; i < 8; i++) {
                    const rawValue = (filteredResponse[3 + i * 2] << 8) | filteredResponse[4 + i * 2];  // Rohdaten extrahieren
                    const mode = globalModeData[i];  // Modus bestimmen
                    let voltage = 0, current = 0;

                    if (mode === "0 bis 5V") {
                        voltage = rawValue / 1000;  // Spannung berechnen
                    } else if (mode === "1 bis 5V") {
                        voltage = rawValue / 1000;  // Spannung berechnen
                    } else if (mode === "0 bis 20mA") {
                        voltage = rawValue / 4095;  // Spannung berechnen
                        current = voltage / 249;  // Strom berechnen
                    } else if (mode === "4 bis 20mA") {
                        voltage = rawValue / 4095;  // Spannung berechnen
                        current = voltage / 249;  // Strom berechnen
                    } else if (mode === "4096-Skala") {
                        voltage = rawValue / 4095;  // Spannung berechnen
                        current = voltage / 249;  // Strom berechnen
                    }

                    channelDataa[i] = { mode, raw: rawValue, voltage, current };  // Kanaldaten aktualisieren
                    globalRawData[i] = rawValue;  // Globale Rohdaten aktualisieren

                    logMessage(`Kanal ${i + 1}: ${voltage.toFixed(5)} V ${current > 0 ? `| ${current.toFixed(5)} mA` : ""}`);  // Log-Nachricht über die Kanaldaten
                }
            } else {
                logMessage("Fehler beim Lesen der Eingänge oder ungültige Daten erhalten.", "error");  // Fehler loggen
            }
        }
}

// Funktion zur Berechnung des CRC (Cyclic Redundancy Check) für ein Modbus-Paket
        function calculateCRC(buffer) {
            let crc = 0xFFFF;  // Initialer Wert für das CRC
            for (let pos = 0; pos < buffer.length; pos++) {
                crc ^= buffer[pos];  // Byte für Byte XOR-Verknüpfung
                for (let i = 8; i !== 0; i--) {  // Für jedes Bit
                    if ((crc & 0x0001) !== 0) {
                        crc >>= 1;  // Bit-Rechtsverschiebung
                        crc ^= 0xA001;  // CRC XOR-Maske anwenden
                    } else {
                        crc >>= 1;  // Bit-Rechtsverschiebung
                    }
                }
            }
            return crc;  // Berechnetes CRC zurückgeben
        }

        return { ModbusDevice, calculateCRC };  // Export der ModbusDevice-Klasse und der calculateCRC-Funktion
    })();

    // Modul zur Verwaltung der USB-Verbindung
    const usbConnection = (() => {
        // Funktion zum Verbinden mit einem USB-Gerät
        async function connectUSB() {
            logMessage("Versuche, ein WebUSB-Gerät zu verbinden...");  // Log-Nachricht über den Verbindungsversuch
            try {
                usbDevice = await navigator.usb.requestDevice({ filters: [{ vendorId: 0x0403, productId: 0x6001 }] });  // USB-Gerät anfordern
                await usbDevice.open();  // Gerät öffnen
                await usbDevice.selectConfiguration(1);  // Konfiguration auswählen
                await usbDevice.claimInterface(0);  // Interface beanspruchen
                modbusDevice = new modbusOperations.ModbusDevice(usbDevice);  // Modbus-Gerät initialisieren
                logMessage("WebUSB-Gerät verbunden und RS485-Bus initialisiert.");  // Log-Nachricht über erfolgreiche Verbindung
                updateLed(document.querySelector(SELECTORS.usbLed), true);  // USB-LED auf grün setzen
            } catch (error) {
                logMessage(`Verbindungsfehler: ${error.message}`, 'error');  // Fehler loggen
                updateLed(document.querySelector(SELECTORS.usbLed), false);  // USB-LED auf rot setzen
            }
        }
        return { connectUSB };  // Export der connectUSB-Funktion
    })();






        
// Neue Erweiterungen beginnen hier
// Web Worker Code als String
const workerCode = `
    let backgroundInterval = 10000; // Intervall, wenn die Seite im Hintergrund ist
    let intervalId;

    // Funktion zum Starten des Intervalls
    function startInterval() {
        clearInterval(intervalId);
        intervalId = setInterval(() => {
            self.postMessage('executeAutoMode');
        }, backgroundInterval);
    }

    // Funktion zum Stoppen des Intervalls
    function stopInterval() {
        clearInterval(intervalId);
    }

    // Event-Listener für Nachrichten vom Hauptthread
    self.onmessage = function(e) {
        if (e.data.action === 'start') {
            startInterval();
        } else if (e.data.action === 'stop') {
            stopInterval();
        }
    };
`;

// Blob und Worker erstellen
const blob = new Blob([workerCode], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(blob);
const worker = new Worker(workerUrl);

// Message-Listener im Hauptthread für Nachrichten vom Worker
worker.onmessage = function(e) {
    if (e.data === 'executeAutoMode') {
        executeAutoMode();
    }
};

// Flag, um den Zustand des Auto-Modus zu verfolgen
let autoModeActiveBeforeBackground = false;

// Event-Listener für Fokusverlust (blur)
window.addEventListener('blur', handleBlur);

// Event-Listener für Fokusgewinn (focus)
window.addEventListener('focus', handleFocus);

// Funktion zur Behandlung von Fokusverlust
function handleBlur() {
    autoModeActiveBeforeBackground = driverEnabled;
    if (autoModeActiveBeforeBackground) {
        
    stoppPeriodicRead();
    stopPeriodicRead(); // Periodisches Auslesen stoppen
            readAllChannelsButton.disabled = false; // Wieder aktivieren für manuellen Zugriff
        setTimeout(() => {
            worker.postMessage({ action: 'start' });
        }, 1000);
    }
}

// Funktion zur Behandlung von Fokusgewinn
function handleFocus() {
    if (autoModeActiveBeforeBackground) {
        worker.postMessage({ action: 'stop' });
        autoModeActiveBeforeBackground = false; // Zustand zurücksetzen
     //   startPeriodicRead();
         
          starttPeriodicRead(); 
           autoModeActiveBeforeBackground = false; // Zustand zurücksetzen
        clearCache();
    }
}

// Funktion zum Ausführen des Auto-Modus
async function executeAutoMode() {
    try {
        logMessage("[INFO] Führe Auto-Modus aus...");
        for (let i = 0; i < 8; i++) {
            await modbusDevice.readRegister(0x1000 + i);
        }
        await modbusDevice.readInputs();
        updateChannelDataBox();
        saveTableDataToLocalStorage();
        logMessage("[INFO] Auto-Modus erfolgreich abgeschlossen.");
    } catch (error) {
        logMessage(`[FEHLER] Fehler im Auto-Modus: ${error.message}`, "error");
    }
}

// Funktion zum Starten des periodischen Lesens
function starttPeriodicRead() {
    if (driverEnabled) {
        if (!document.hasFocus()) {
            worker.postMessage({ action: 'start' });
        } else {
            periodicReadId = setInterval(executeAutoMode, readInterval);
        }
    }
}

// Funktion zum Stoppen des periodischen Lesens
function stoppPeriodicRead() {
    if (!document.hasFocus()) {
        worker.postMessage({ action: 'stop' });
            stopPeriodicRead(); // Periodisches Auslesen stoppen
            readAllChannelsButton.disabled = false; // Wieder aktivieren für manuellen Zugriff
autoModeActiveBeforeBackground = true;
    } else {
        clearInterval(periodicReadId);
    }
}

// Cache-Bereinigung beim Wiedererlangen des Fokus
function clearCache() {
    // Beispiel für Cache-Bereinigung
    caches.keys().then((names) => {
        for (let name of names) {
            caches.delete(name);
        }
    });
}

// Neue Funktionen und Verbesserungen hier






document.body.addEventListener('click', async (event) => {
    if (event.target.matches(SELECTORS.connectUSBButton)) {
        usbConnection.connectUSB();  // USB-Verbindung herstellen
    } else if (event.target.matches(SELECTORS.toggleDriverButton)) {
        driverEnabled = !driverEnabled;  // Auto-Modus aktivieren/deaktivieren
        updateLed(document.querySelector(SELECTORS.driverLed), driverEnabled);  // Treiber-LED aktualisieren
        logMessage(`Auto-Modus ${driverEnabled ? 'aktiviert' : 'deaktiviert'}`);  // Log-Nachricht über Treiberstatus
        
        // Aktivieren/Deaktivieren des "Alle Eingänge auslesen"-Buttons
        const readAllChannelsButton = document.querySelector(SELECTORS.readAllChannelsButton);
        if (driverEnabled) {
            readAllChannelsButton.disabled = true; // Deaktivieren, da Auto-Modus übernimmt
            startPeriodicRead(); // Periodisches Auslesen starten
        } else {
            stopPeriodicRead(); // Periodisches Auslesen stoppen
            readAllChannelsButton.disabled = false; // Wieder aktivieren für manuellen Zugriff
        }
    } else if (event.target.matches(SELECTORS.toggleDebugButton)) {
        debugEnabled = !debugEnabled;  // Debug-Modus aktivieren/deaktivieren
        updateLed(document.querySelector(SELECTORS.debugLed), debugEnabled);  // Debug-LED aktualisieren
        logMessage(`Debug Modus ${debugEnabled ? 'aktiviert' : 'deaktiviert'}`);  // Log-Nachricht über Debug-Status
    } else if (event.target.matches(SELECTORS.readRegisterButton)) {
        const channel = parseInt(document.querySelector(SELECTORS.channelSelect).value) - 1;  // Kanal auswählen
        await modbusDevice.readRegister(0x1000 + channel);  // Register auslesen
    } else if (event.target.matches(SELECTORS.writeRegisterButton)) {
        const channel = parseInt(document.querySelector(SELECTORS.channelSelect).value) - 1;  // Kanal auswählen
        const mode = parseInt(document.querySelector(SELECTORS.modeSelect).value);  // Modus auswählen
        await modbusDevice.writeRegister(0x1000 + channel, mode);  // Register schreiben
    } else if (event.target.matches(SELECTORS.readAllChannelsButton)) {
        logMessage("Lese Register für alle Kanäle...");  // Log-Nachricht über Lesevorgang
        for (let i = 0; i < 8; i++) {
            await modbusDevice.readRegister(0x1000 + i);  // Alle Register auslesen
        }
        logMessage("Berechne und lese alle Eingänge...");  // Log-Nachricht über Eingangs-Lesevorgang
        await modbusDevice.readInputs();  // Alle Eingänge auslesen
        updateChannelDataBox();  // Kanaldatenanzeige aktualisieren
    } else if (event.target.matches(SELECTORS.clearLog)) {
        document.querySelector(SELECTORS.logBox).value = '';  // Log leeren
        logMessage("Log geleert.");  // Log-Nachricht über das Leeren des Logs
    } else if (event.target.matches(SELECTORS.setSerialConfigButton)) {
        currentBaudRate = parseInt(document.querySelector(SELECTORS.baudRateSelect).value, 10);  // Baudrate aktualisieren
        currentParity = document.querySelector(SELECTORS.paritySelect).value;  // Parität aktualisieren
        currentStopBits = parseInt(document.querySelector(SELECTORS.stopBitsSelect).value, 10);  // Stopbits aktualisieren
        logMessage(`Serielle Konfiguration aktualisiert: Baudrate=${currentBaudRate}, Parität=${currentParity}, Stopbits=${currentStopBits}`);  // Log-Nachricht über aktualisierte Konfiguration
    }
});

document.body.addEventListener('change', (event) => {
    if (event.target.matches(SELECTORS.readIntervalInput)) {
        const newInterval = parseInt(event.target.value, 10);
        if (newInterval >= 1 && newInterval <= 300) {
            readInterval = newInterval * 1000; // In Millisekunden umwandeln
            logMessage(`Zeittakt auf ${newInterval} Sekunden gesetzt.`);
        } else {
            readInterval = 60000; // Standardwert auf 60 Sekunden setzen
            event.target.value = 60; // Eingabewert ebenfalls auf 60 setzen
            logMessage("Ungültiger Wert! Der Zeittakt muss zwischen 1 und 300 Sekunden liegen. Standardwert auf 60 Sekunden gesetzt.", "error");
        }
    }
});

// Initialisiere die zentrale Steuerungsfunktion
mainController();
function calculateValues() {
    return globalRawData.map((raw, index) => {
        const mode = globalModeData[index];
        const { voltage, current } = channelDataa[index]; // Bereits berechnete Werte verwenden
        return { mode, raw, voltage, current };
    });
}

    // Funktion zur Aktualisierung der Ergebnissebox
    function updateResultsBox() {
        const resultsBox = document.querySelector(SELECTORS.resultsBox);  // Ergebnissebox selektieren
        const tableHeader = `
            <table>
                <thead>
                    <tr>
                        <th>Kanal</th>
                        <th>Modus</th>
                        <th>Rohdaten</th>
                        <th>Spannung (V)</th>
                        <th>Strom (mA)</th>
                    </tr>
                </thead>
                <tbody>
        `;
        const tableFooter = `
                </tbody>
            </table>
        `;

        let tableRows = calculateValues().map((data, index) => {
            return `
                <tr>
                    <td>${index + 1}</td>
                    <td>${data.mode}</td>
                    <td>${data.raw}</td>
                    <td>${data.voltage.toFixed(5)}</td>
                    <td>${data.current ? data.current.toFixed(5) : 'N/A'}</td>
                </tr>
            `;
        }).join('');

        resultsBox.innerHTML = tableHeader + tableRows + tableFooter;  // Ergebnisse in die Ergebnissebox einfügen
    }

    // Event-Listener für den "Alle Eingänge auslesen"-Button
    document.querySelector(SELECTORS.readAllChannelsButton).addEventListener('click', updateResultsBox);



</script>

</body>
</html>