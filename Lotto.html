<!DOCTYPE html>
<!--
 - Version: 1.1.2 (Optimierung: Fortschritt zeigt jetzt aktuelle Kombination und Gesamt-Kombinationen)
 - Zeigt bei jeder Stufe die aktuelle und die Gesamtanzahl der Kombinationen während der Optimierung.
 - Stand: 24. Mai 2025
 - Link: https://github.com/JohannesFriedrich/LottoNumberArchive
-->
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lotto 6aus49 KI-Analyzer</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.1.0/dist/chartjs-chart-matrix.min.js"></script>
  <style>
    :root {
      --hot-color: #ff4444;
      --cold-color: #4285f4;
      --neutral-color: #4CAF50;
      --button-bg: #4CAF50;
      --button-hover: #45a049;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 0;
      background-color: #f5f5f5;
    }
    .content-wrapper {
      padding: 20px; margin-bottom: 140px;
    }
    h1 {
      text-align: center; margin-top: 0; font-size: 1.5em;
    }
    h4 {
      text-align: center; margin-top: 0; font-size: 1.1em;
    }
    #controls {
      display: flex; flex-direction: column; align-items: center;
      gap: 10px; margin-bottom: 20px;
    }
    select, input[type="file"], button {
      padding: 10px; font-size: 14px;
      border-radius: 5px; border: 1px solid #ccc;
    }
    button {
      background-color: var(--button-bg);
      color: white; border: none; cursor: pointer;
      transition: background 0.15s;
    }
    button:disabled {
      background-color: #bdbdbd !important;
      cursor: not-allowed;
    }
    button:hover:enabled {
      background-color: var(--button-hover);
    }
    .number-container {
      display: flex; justify-content: center; flex-wrap: wrap;
      gap: 5px;
    }
    .number {
      display: inline-flex; align-items: center; justify-content: center;
      width: 32px; height: 32px;
      background: var(--neutral-color); color: white;
      border-radius: 50%; font-weight: bold;
    }
    .superzahl-display {
      background: #FFC107; color: #333;
    }
    .chart-container {
      margin-bottom: 30px;
    }
    canvas {
      background: white; border-radius: 8px; padding: 10px;
    }
    .heatmap-container {
      width: 100%; max-height: 600px; overflow: auto;
    }
    .advanced-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px; margin-top: 20px;
    }
    .stat-box {
      padding: 15px; background: #f8f9fa; border-radius: 8px;
      border-left: 4px solid var(--neutral-color);
    }
    .stat-box.hot {
      border-color: var(--hot-color);
    }
    #topNumbersFooter {
      position: fixed; bottom: 0; left: 0; right: 0;
      background: #e9e9e9; padding: 10px; text-align: center;
      border-top: 2px solid var(--neutral-color); z-index: 1000;
    }
    #topNumbersFooter h2 {
      margin: 0 0 5px 0; font-size: 0.9em;
    }
    @media (max-width: 480px) {
      .number { width: 28px; height: 28px; font-size: 13px; }
    }
    .dieter-weights-box {
      background: #e7f3e7;
      border-radius: 8px;
      padding: 12px 15px 10px 15px;
      margin: 10px 0 15px 0;
      box-shadow: 0 1px 3px rgba(76,175,80,0.07);
      max-width: 600px;
      margin-left: auto; margin-right: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .dieter-weights-box .weight-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .dieter-weights-box .weight-row label {
      display: flex;
      align-items: center;
      gap: 5px;
      min-width: 140px;
    }
    .dieter-weights-box input[type="number"],
    .dieter-weights-box input[type="text"] {
      width: 80px;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #bbb;
    }
    .dieter-weights-box .bereichsfeld {
      width: 50px !important;
      margin: 0 !important;
    }
    .dieter-weights-box .anzahl-label {
      color: #666;
      font-size: 0.97em;
      margin-left: 10px;
      min-width: 70px;
      display: inline-block;
      text-align: left;
    }
    .dieter-backtest-box {
      background: #fffbe7;
      border-radius: 8px;
      padding: 12px 15px 10px 15px;
      margin: 10px 0 15px 0;
      box-shadow: 0 1px 3px rgba(255,193,7,0.08);
      max-width: 600px;
      margin-left: auto; margin-right: auto;
    }
    .dieter-backtest-box h3 {
      margin-top: 0;
      margin-bottom: 7px;
      font-size: 1.1em;
    }
    .dieter-backtest-box .dieter-backtest-btns {
      display: flex;
      gap: 12px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
    }
    .dieter-backtest-results table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 5px;
      font-size: 0.96em;
    }
    .dieter-backtest-results th, .dieter-backtest-results td {
      padding: 3px 6px;
      border-bottom: 1px solid #eee;
      text-align: center;
    }
    .dieter-backtest-results th {
      background: #fff6c1;
    }
    .dieter-backtest-results .right {
      color: var(--hot-color); font-weight: bold;
    }
    .dieter-backtest-results .zero {
      color: #bbb;
    }
    #btnAutoOptimize {
      background-color: #ff9800;
      font-weight: bold;
    }
    #btnAutoOptimize:hover {
      background-color: #e68900;
    }
    #autoOptimizeProgress {
      font-size: 0.96em;
      color: #666;
      margin-top: 8px;
      min-height: 1.7em;
    }
    #autoOptimizeResult {
      font-size: 1em;
      color: #333;
      margin-top: 7px;
    }
  </style>
</head>
<body>
  <div class="content-wrapper">
    <h1>Lotto 6aus49 KI-Analyzer</h1>
    <h4>Version: 1.1.2 (Kombinations-Fortschritt bei Optimierung)</h4>
    <div id="controls">
      <button id="githubBtn">Daten von GitHub laden</button>
      <input type="file" id="fileInput" accept=".json" />
      <select id="dataSubsetSelect">
        <option value="all">Alle Ziehungen verwenden</option>
        <option value="3000">Letzte 3000 Ziehungen</option>
        <option value="2000">Letzte 2000 Ziehungen</option>
        <option value="1000">Letzte 1000 Ziehungen</option>
        <option value="500">Letzte 500 Ziehungen</option>
        <option value="100">Letzte 100 Ziehungen</option>
        <option value="50">Letzte 50 Ziehungen</option>
        <option value="25">Letzte 25 Ziehungen</option>
        <option value="10">Letzte 10 Ziehungen</option>
      </select>
      <button id="analyzeBtn" disabled>Analyse starten</button>
      <div id="loadingStatus" class="loading-message" style="display: none; color: #888;"></div>
    </div>
    <!-- Dieter-Weights-Box MIT ANZAHL -->
    <div class="dieter-weights-box">
      <strong>Dieter-Prognose Gewichtung:</strong>
      <div class="weight-row">
        <label for="weightLong">Alle Ziehungen:</label>
        <input type="number" id="weightLong" value="8.00" min="0" step="0.1">
        <span class="anzahl-label" id="anzahlAlleZiehungen"></span>
      </div>
      <div class="weight-row">
        <label>Letzte <input type="text" id="bereich1000" class="bereichsfeld" value="3500">:</label>
        <input type="text" id="weight1000" value="2.40">
        <span class="anzahl-label" id="anzahlLetzte1000"></span>
      </div>
      <div class="weight-row">
        <label>Letzte <input type="text" id="bereich100" class="bereichsfeld" value="2000">:</label>
        <input type="text" id="weight100" value="1.30">
        <span class="anzahl-label" id="anzahlLetzte100"></span>
      </div>
      <div class="weight-row">
        <label>Letzte <input type="text" id="bereich25" class="bereichsfeld" value="1000">:</label>
        <input type="text" id="weight25" value="0.62">
        <span class="anzahl-label" id="anzahlLetzte25"></span>
      </div>
    </div>
    <div class="dieter-backtest-box">
      <h3>Backtest: Dieter-Prognose auf die letzten 50 Ziehungen</h3>
      <div class="dieter-backtest-btns">
        <button id="btnRunDieterBacktest">Backtest jetzt ausführen</button>
        <button id="btnAutoOptimize" title="Finde automatisch die beste Dieter-Gewichtung!">Automatisch optimieren</button>
      </div>
      <div id="autoOptimizeProgress"></div>
      <div id="autoOptimizeResult"></div>
      <div id="dieterBacktestResults" class="dieter-backtest-results" style="margin-top:10px;">Noch keine Auswertung.</div>
    </div>

    <div class="chart-container">
      <h3>Häufigkeit Lottozahlen (1–49)</h3>
      <canvas id="freqChart" width="600" height="300"></canvas>
    </div>
    <div class="chart-container">
      <h3>Häufigkeit Superzahlen (0–9)</h3>
      <canvas id="superzahlFreqChart" width="600" height="300"></canvas>
    </div>
    <div class="advanced-stats">
      <div class="stat-box" id="chiSquareResult">
        <h3>Chi-Quadrat-Test</h3>
        <p>Lädt...</p>
      </div>
      <div class="stat-box" id="hotColdInfo">
        <h3>Hot/Cold-Zahlen</h3>
        <div id="hotColdNumbers" class="number-container"></div>
      </div>
      <div class="stat-box">
        <h3>Entropie (Lottozahlen)</h3>
        <canvas id="entropyGauge" width="300" height="150"></canvas>
      </div>
    </div>
    <div class="chart-container">
      <h3>Übergangswahrscheinlichkeiten (Heatmap)</h3>
      <div class="heatmap-container">
        <canvas id="transitionHeatmap" width="600" height="600"></canvas>
      </div>
    </div>
    <div class="advanced-stats">
      <div class="stat-box">
        <h3>KI-basierte Vorhersage</h3>
        <p>Diese Zahlen kombinieren Häufigkeit, Trends, Entropie & Übergänge:</p>
        <div id="kiTopNumbers" class="number-container"></div>
      </div>
      <div class="stat-box" style="max-height: 200px; overflow-y: auto;">
        <h3>Dieter-Prognose (Mehr-Ebenen-Analyse)</h3>
        <p>Langzeit-Defizit + Kurzfrist-Filter + KI-Gewichtung + Gewichtungseinstellungen:</p>
        <div id="dieterPrognoseList" class="number-container"></div>
      </div>
    </div>
    <div id="topNumbersFooter">
      <div class="top-section">
        <h2>Top 6 Lottozahlen</h2>
        <div id="topLottozahlenList" class="number-container"></div>
      </div>
      <div class="top-section">
        <h2>Top Superzahl</h2>
        <div id="topSuperzahlList" class="number-container"></div>
      </div>
    </div>
    <script>
      // === Dieter-Prognose Standardwerte ===
      let DIETER_WEIGHT_LONG  = 8.0;
      let DIETER_WEIGHT_1000  = 2.4;
      let DIETER_WEIGHT_100   = 1.3;
      let DIETER_WEIGHT_25    = 0.62;
      let DIETER_BEREICH_1000 = 2500;
      let DIETER_BEREICH_100  = 1250;
      let DIETER_BEREICH_25   = 625;

      // Hilfsfunktion für Ziehungszahlen-Anzeige
      function updateZiehungsAnzeigen() {
        const alle = allLottoEntries ? allLottoEntries.length : 0;
        document.getElementById('anzahlAlleZiehungen').textContent = alle ? `(${alle} )` : '';
        document.getElementById('anzahlLetzte1000').textContent = (DIETER_BEREICH_1000 && alle) ? `(${Math.min(DIETER_BEREICH_1000, alle)} )` : '';
        document.getElementById('anzahlLetzte100').textContent  = (DIETER_BEREICH_100 && alle) ? `(${Math.min(DIETER_BEREICH_100, alle)} )` : '';
        document.getElementById('anzahlLetzte25').textContent   = (DIETER_BEREICH_25 && alle) ? `(${Math.min(DIETER_BEREICH_25, alle)} )` : '';
      }
      function updateDieterWeightsFromUI() {
        DIETER_WEIGHT_LONG  = parseFloat(document.getElementById('weightLong').value) || 0;
        DIETER_WEIGHT_1000 = parseFloat(document.getElementById('weight1000').value.replace(',','.')) || 0;
        DIETER_WEIGHT_100  = parseFloat(document.getElementById('weight100').value.replace(',','.')) || 0;
        DIETER_WEIGHT_25   = parseFloat(document.getElementById('weight25').value.replace(',','.')) || 0;
        DIETER_BEREICH_1000 = parseInt(document.getElementById('bereich1000').value) || 0;
        DIETER_BEREICH_100  = parseInt(document.getElementById('bereich100').value) || 0;
        DIETER_BEREICH_25   = parseInt(document.getElementById('bereich25').value) || 0;
        updateZiehungsAnzeigen();
      }
      function setDieterWeightsToUI(long, t1000, t100, t25, b1000, b100, b25) {
        document.getElementById('weightLong').value  = long;
        document.getElementById('weight1000').value = t1000;
        document.getElementById('weight100').value  = t100;
        document.getElementById('weight25').value   = t25;
        document.getElementById('bereich1000').value = b1000;
        document.getElementById('bereich100').value  = b100;
        document.getElementById('bereich25').value   = b25;
        updateDieterWeightsFromUI();
      }
      document.addEventListener('DOMContentLoaded', () => {
        setDieterWeightsToUI(8.0, 2.4, 1.3, 0.62, 2500, 1250, 625);
      });
      ['weightLong','weight1000','weight100','weight25','bereich1000','bereich100','bereich25'].forEach(id => {
        document.addEventListener('DOMContentLoaded', () => {
          document.getElementById(id).addEventListener('input', updateDieterWeightsFromUI);
        });
      });

      // --- Buttons: Backtest & Auto-Optimierung ---
      document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('btnRunDieterBacktest').addEventListener('click', function() {
          if (!isOptimizing) runDieterBacktest();
        });
        document.getElementById('btnAutoOptimize').addEventListener('click', function() {
          if (!isOptimizing) runDieterAutoOptimizeWorker();
        });
      });

      // --- DATA LOADING und Hilfsfunktionen ---
      const GITHUB_URL = "https://raw.githubusercontent.com/JohannesFriedrich/LottoNumberArchive/a2c9e5f3abb461cef301010548c7ed6160b98008/Lottonumbers_complete.json";
      let allLottoEntries = [], chartInstances = {}, transitionMatrix = [], chiSquareResult = 0, expectedFrequency = 0, hotColdMap = [], entropyChart;
      let isOptimizing = false;

      window.addEventListener('load', () => loadGitHubJson());
      document.getElementById('githubBtn').addEventListener('click', loadGitHubJson);
      document.getElementById('fileInput').addEventListener('change', handleFileInput);
      document.getElementById('analyzeBtn').addEventListener('click', performAnalysis);

      function showLoadingMessage(msg) {
        const el = document.getElementById('loadingStatus');
        el.textContent = msg; el.style.display = 'block';
      }
      function hideLoadingMessage() {
        document.getElementById('loadingStatus').style.display = 'none';
      }
      async function loadGitHubJson() {
        document.getElementById('analyzeBtn').disabled = true;
        showLoadingMessage("Lade Daten von GitHub...");
        try {
          const res = await fetch(GITHUB_URL);
          if (!res.ok) throw new Error(res.status);
          const json = await res.json();
          validateAndProcessData(json, "GitHub");
        } catch (err) { handleError("Ladefehler: ", err); }
        finally { hideLoadingMessage(); }
      }
      function handleFileInput(e) {
        const file = e.target.files[0]; if (!file) return;
        showLoadingMessage("Verarbeite Datei...");
        const reader = new FileReader();
        reader.onload = evt => {
          try {
            const json = JSON.parse(evt.target.result);
            validateAndProcessData(json, "Datei");
          } catch (err) { handleError("Parsefehler: ", err); }
          finally { hideLoadingMessage(); }
        };
        reader.readAsText(file);
      }
      function validateAndProcessData(json, source) {
        if (!json || !Array.isArray(json.data)) throw new Error("Struktur");
        allLottoEntries = json.data;
        if (!allLottoEntries.length) throw new Error("Keine Daten");
        document.getElementById('analyzeBtn').disabled = false;
        updateZiehungsAnzeigen();
        alert(`Daten von ${source} geladen: ${allLottoEntries.length} Ziehungen.`);
      }
      function handleError(msg, err) {
        console.error(msg, err);
        alert(msg + err.message);
      }

      // --- WebWorker für Auto-Optimierung ---
      // Inline-Worker-Code für maximale Kompatibilität
      let autoOptimizeWorker;
      function runDieterAutoOptimizeWorker() {
        updateDieterWeightsFromUI();
        const N = 50;
        const progressEl = document.getElementById('autoOptimizeProgress');
        const resultEl = document.getElementById('autoOptimizeResult');
        const btnBacktest = document.getElementById('btnRunDieterBacktest');
        const btnOptim = document.getElementById('btnAutoOptimize');
        const minData = Math.max(DIETER_BEREICH_1000, DIETER_BEREICH_100, DIETER_BEREICH_25, 1000);

        if (!allLottoEntries || allLottoEntries.length < N + minData) {
          progressEl.textContent = "Nicht genug Daten für Optimierung!";
          return;
        }

        progressEl.textContent = `Initialisiere Optimierung... (Datensatz: ${allLottoEntries.length} Ziehungen)`;
        resultEl.textContent = "";
        btnBacktest.disabled = true;
        btnOptim.disabled = true;
        isOptimizing = true;

        if (autoOptimizeWorker) {
          autoOptimizeWorker.terminate();
        }

        // Worker-Code als Blob (damit kompatibel mit allen Browsern)
        const workerCode = `
        self.onmessage = function(e) {
          const {allLottoEntries, N, DIETER_BEREICH_1000, DIETER_BEREICH_100, DIETER_BEREICH_25, steps} = e.data;
          function defizitArray(entries) {
            const freq = Array(49).fill(0);
            entries.forEach(e => e.Lottozahl?.forEach(z => freq[parseInt(z) - 1]++));
            return freq;
          }
          function runDieterBacktest(wLong, w1000, w100, w25) {
            let trefferStat = [0,0,0,0,0,0,0];
            for (let i = allLottoEntries.length - N; i < allLottoEntries.length; i++) {
              const vergangene = allLottoEntries.slice(0, i);
              const alle = vergangene;
              const letzte1000 = DIETER_BEREICH_1000 > 0 ? vergangene.slice(-DIETER_BEREICH_1000) : null;
              const letzte100  = DIETER_BEREICH_100  > 0 ? vergangene.slice(-DIETER_BEREICH_100 ) : null;
              const letzte25   = DIETER_BEREICH_25   > 0 ? vergangene.slice(-DIETER_BEREICH_25  ) : null;
              const ziehungen_all   = alle.length * 6;
              const ziehungen_1000  = letzte1000 ? letzte1000.length * 6 : 0;
              const ziehungen_100   = letzte100  ? letzte100.length * 6  : 0;
              const ziehungen_25    = letzte25   ? letzte25.length * 6   : 0;
              const def_all   = defizitArray(alle).map(c => ziehungen_all/49   - c);
              const def_1000  = letzte1000 ? defizitArray(letzte1000).map(c => ziehungen_1000/49 - c) : Array(49).fill(0);
              const def_100   = letzte100  ? defizitArray(letzte100 ).map(c => ziehungen_100/49  - c) : Array(49).fill(0);
              const def_25    = letzte25   ? defizitArray(letzte25  ).map(c => ziehungen_25/49   - c) : Array(49).fill(0);
              const kombiScore = Array(49).fill(0).map((_, i) =>
                wLong  * def_all[i] +
                (DIETER_BEREICH_1000 > 0 && w1000 > 0 ? w1000 * def_1000[i] : 0) +
                (DIETER_BEREICH_100  > 0 && w100  > 0 ? w100  * def_100[i]  : 0) +
                (DIETER_BEREICH_25   > 0 && w25   > 0 ? w25   * def_25[i]   : 0)
              );
              const bewertet = kombiScore.map((defi, i) => ({
                zahl: i + 1,
                score: defi
              }));
              const top6 = bewertet.sort((a, b) => b.score - a.score).slice(0, 6).map(e=>e.zahl);
              const gezogen = allLottoEntries[i].Lottozahl.map(Number);
              let richtig = top6.filter(z => gezogen.includes(z)).length;
              trefferStat[richtig]++;
            }
            const schnitt = (trefferStat.reduce((s,c,i)=>s+c*i,0) / N);
            return {schnitt, trefferStat};
          }
          function getTotalComb(params) {
            const keys = ['wLong','w1000','w100','w25'];
            const ranges = keys.map(k => {
              let {min,max,step} = params[k];
              min = Math.round(min*1000)/1000;
              max = Math.round(max*1000)/1000;
              let arr = [];
              for(let v=min; v<=max+1e-6; v+=step) arr.push(Math.round(v*1000)/1000);
              return arr;
            });
            return ranges.reduce((a,arr) => a*arr.length, 1);
          }
          async function doOptimize(params, progressStep, step, totalSteps) {
            const keys = ['wLong','w1000','w100','w25'];
            const ranges = keys.map(k => {
              let {min,max,step} = params[k];
              min = Math.round(min*1000)/1000;
              max = Math.round(max*1000)/1000;
              let arr = [];
              for(let v=min; v<=max+1e-6; v+=step) arr.push(Math.round(v*1000)/1000);
              return arr;
            });
            const totalComb = ranges.reduce((a,arr) => a*arr.length, 1);
            let bestScore = -1, bestW = null, bestStat = [];
            let checked = 0;
            for(let wLong of ranges[0]) for(let w1000 of ranges[1]) for(let w100 of ranges[2]) for(let w25 of ranges[3]) {
              if (wLong === 0 && w1000 === 0 && w100 === 0 && w25 === 0) continue;
              const stat = runDieterBacktest(wLong, w1000, w100, w25);
              if(stat.schnitt>bestScore) {
                bestScore=stat.schnitt;
                bestW={wLong,w1000,w100,w25};
                bestStat = stat.trefferStat.slice();
              }
              checked++;
              if(checked%500===0) {
                self.postMessage({type:'progress', progress: Math.floor(checked/totalComb*100), checked, totalComb, step, totalSteps, datensatz: allLottoEntries.length});
                await new Promise(r=>setTimeout(r,0));
              }
            }
            return {...bestW, score:bestScore, trefferStat:bestStat, datensatz: allLottoEntries.length, totalComb};
          }
          (async function(){
            const total1 = getTotalComb(steps.coarse);
            self.postMessage({type:'progress', progress:0, checked:0, totalComb:total1, step:1, totalSteps:3, datensatz: allLottoEntries.length});
            let best = await doOptimize(steps.coarse, 0, 1, 3);
            const total2 = getTotalComb({
              wLong:  { min: Math.max(0, best.wLong-6),    max: Math.min(40, best.wLong+6),   step: steps.fine.wLong.step },
              w1000:  { min: Math.max(0, best.w1000-2),    max: Math.min(20, best.w1000+2),   step: steps.fine.w1000.step },
              w100:   { min: Math.max(0, best.w100-0.8),   max: Math.min(6, best.w100+0.8),   step: steps.fine.w100.step },
              w25:    { min: Math.max(0, best.w25-0.2),    max: Math.min(2, best.w25+0.2),    step: steps.fine.w25.step }
            });
            self.postMessage({type:'progress', progress:0, checked:0, totalComb:total2, step:2, totalSteps:3, datensatz: allLottoEntries.length});
            let fineParams = {
              wLong:  { min: Math.max(0, best.wLong-6),    max: Math.min(40, best.wLong+6),   step: steps.fine.wLong.step },
              w1000:  { min: Math.max(0, best.w1000-2),    max: Math.min(20, best.w1000+2),   step: steps.fine.w1000.step },
              w100:   { min: Math.max(0, best.w100-0.8),   max: Math.min(6, best.w100+0.8),   step: steps.fine.w100.step },
              w25:    { min: Math.max(0, best.w25-0.2),    max: Math.min(2, best.w25+0.2),    step: steps.fine.w25.step }
            };
            best = await doOptimize(fineParams, 0, 2, 3);
            const total3 = getTotalComb({
              wLong:  { min: Math.max(0, best.wLong-2),   max: Math.min(40, best.wLong+2),   step: steps.ultra.wLong.step },
              w1000:  { min: Math.max(0, best.w1000-1),   max: Math.min(20, best.w1000+1),   step: steps.ultra.w1000.step },
              w100:   { min: Math.max(0, best.w100-0.3),  max: Math.min(6, best.w100+0.3),   step: steps.ultra.w100.step },
              w25:    { min: Math.max(0, best.w25-0.08),  max: Math.min(2, best.w25+0.08),   step: steps.ultra.w25.step }
            });
            self.postMessage({type:'progress', progress:0, checked:0, totalComb:total3, step:3, totalSteps:3, datensatz: allLottoEntries.length});
            let ultraParams = {
              wLong:  { min: Math.max(0, best.wLong-2),   max: Math.min(40, best.wLong+2),   step: steps.ultra.wLong.step },
              w1000:  { min: Math.max(0, best.w1000-1),   max: Math.min(20, best.w1000+1),   step: steps.ultra.w1000.step },
              w100:   { min: Math.max(0, best.w100-0.3),  max: Math.min(6, best.w100+0.3),   step: steps.ultra.w100.step },
              w25:    { min: Math.max(0, best.w25-0.08),  max: Math.min(2, best.w25+0.08),   step: steps.ultra.w25.step }
            };
            best = await doOptimize(ultraParams, 0, 3, 3);
            self.postMessage({type:'done', best});
          })();
        }
        `;
        const blob = new Blob([workerCode], {type:"application/javascript"});
        autoOptimizeWorker = new Worker(URL.createObjectURL(blob));
        // Worker-Nachrichten-Handler
        autoOptimizeWorker.onmessage = function(e) {
          const data = e.data;
          if(data.type==="progress") {
            progressEl.textContent = `Stufe ${data.step}/${data.totalSteps}: ... (${data.progress}%) [${data.checked} von ${data.totalComb} Kombi gep.] `;
          }
          if(data.type==="done") {
            const best = data.best;
            setDieterWeightsToUI(
              best.wLong, best.w1000, best.w100, best.w25,
              DIETER_BEREICH_1000, DIETER_BEREICH_100, DIETER_BEREICH_25
            );
            updateZiehungsAnzeigen();
            progressEl.textContent = `Optimierung abgeschlossen. (Datensatz: ${best.datensatz} Ziehungen)`;
            resultEl.innerHTML = `<strong>Maximaler Schnitt: <span style="color:#ff9800;">${best.score.toFixed(2)}</span> Treffer/Ziehung</strong>
              <br>
              <span style="font-size:0.95em;">(Alle: <b>${best.wLong}</b>, ${DIETER_BEREICH_1000}: <b>${best.w1000}</b>, ${DIETER_BEREICH_100}: <b>${best.w100}</b>, ${DIETER_BEREICH_25}: <b>${best.w25}</b>)</span>
              <br>
              <span style="font-size:0.92em;">Trefferverteilung: [0:${best.trefferStat[0]}, 1:${best.trefferStat[1]}, 2:${best.trefferStat[2]}, 3:${best.trefferStat[3]}, 4:${best.trefferStat[4]}, 5:${best.trefferStat[5]}, 6:${best.trefferStat[6]}]</span>
              <br>
              <span style="color:#666;">Die optimalen Werte wurden automatisch übernommen.</span>`;
            isOptimizing = false;
            btnBacktest.disabled = false;
            btnOptim.disabled = false;
            runDieterBacktest();
          }
        };
        // Schritte-Objekt wie bisher
        autoOptimizeWorker.postMessage({
          allLottoEntries, N, DIETER_BEREICH_1000, DIETER_BEREICH_100, DIETER_BEREICH_25,
          steps: getDynamicOptimizeSteps()
        });
      }
      // --- steps-Objekt wie gehabt ---
      function getDynamicOptimizeSteps() {
        return {
          coarse: {
            wLong:  { min: 0,  max: 40,  step: 8 },
            w1000:  { min: 0,  max: 20,  step: 2 },
            w100:   { min: 0,  max: 6,   step: 0.8 },
            w25:    { min: 0,  max: 2,   step: 0.2 }
          },
          fine: {
            wLong:  { min: 0,  max: 40,  step: 2 },
            w1000:  { min: 0,  max: 20,  step: 0.5 },
            w100:   { min: 0,  max: 6,   step: 0.2 },
            w25:    { min: 0,  max: 2,   step: 0.05 }
          },
          ultra: {
            wLong:  { min: 0,  max: 40,  step: 1 },
            w1000:  { min: 0,  max: 20,  step: 0.2 },
            w100:   { min: 0,  max: 6,   step: 0.1 },
            w25:    { min: 0,  max: 2,   step: 0.01 }
          }
        };
      }

      // --- CHARTS UND ANALYSE ---
      function computeEntropy(freqs) {
        const total = freqs.reduce((a,b) => a+b, 0);
        return freqs.reduce((sum,c) => c===0 ? sum : sum - (c/total)*Math.log2(c/total), 0);
      }
      function renderEntropyGauge(entropy) {
        const ctx = document.getElementById('entropyGauge').getContext('2d');
        if (chartInstances.entropyGauge) chartInstances.entropyGauge.destroy();
        const maxEntropy = Math.log2(49);
        chartInstances.entropyGauge = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['Entropie', 'Rest'],
            datasets: [{
              data: [entropy, maxEntropy - entropy],
              backgroundColor: ['#4CAF50', '#e0e0e0']
            }]
          },
          options: {
            responsive: true,
            cutout: '70%',
            rotation: 270,
            circumference: 180,
            plugins: {
              legend: { display: true, position: 'bottom' },
              title: {
                display: true,
                text: `Entropie: ${entropy.toFixed(2)} / ${maxEntropy.toFixed(2)}`
              }
            }
          }
        });
      }
      function classifyHotColdNumbers(freqs) {
        const mean = freqs.reduce((a, b) => a + b, 0) / freqs.length;
        return freqs.map((f, i) => ({
          number: i + 1,
          status: f > mean * 1.02 ? 'hot' : f < mean * 0.98 ? 'cold' : 'neutral',
          count: f
        }));
      }
      function renderHotColdNumbers(freqs) {
        hotColdMap = classifyHotColdNumbers(freqs);
        const el = document.getElementById('hotColdNumbers');
        el.innerHTML = hotColdMap.map(n => `
          <span class="number" style="background:${{
            hot: 'var(--hot-color)',
            cold: 'var(--cold-color)',
            neutral: 'var(--neutral-color)'
          }[n.status]}">${n.number}</span>`).join('');
      }
      function calculateTransitionMatrix(data) {
        transitionMatrix = Array(49).fill().map(() => Array(49).fill(0));
        data.forEach(e => {
          const nums = e.Lottozahl.map(n => parseInt(n)).sort((a, b) => a - b);
          for (let i = 0; i < nums.length - 1; i++) {
            const from = nums[i] - 1;
            const to = nums[i + 1] - 1;
            if (from >= 0 && to >= 0) transitionMatrix[from][to]++;
          }
        });
      }
      function calculateChiSquare(obs) {
        const total = obs.reduce((a, b) => a + b, 0);
        expectedFrequency = total / 49;
        chiSquareResult = obs.reduce((sum, o) => sum + ((o - expectedFrequency) ** 2) / expectedFrequency, 0);
      }
      function renderChiSquareResult() {
        const critical = 65.171;
        const significant = chiSquareResult > critical;
        const box = document.getElementById('chiSquareResult');
        box.className = `stat-box ${significant ? 'hot' : ''}`;
        box.innerHTML = `
          <h3>Chi-Quadrat-Test</h3>
          <p>Wert: ${chiSquareResult.toFixed(2)}</p>
          <p>Erwartet: ${expectedFrequency.toFixed(1)}</p>
          <p>Signifikanz: ${significant ? '⚠️ Abweichung' : '✅ Normal'}</p>
        `;
      }
      function getTopNumbers(freqs, count, isSuper = false) {
        return freqs.map((c, i) => ({ number: isSuper ? i : i + 1, count: c }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, count);
      }
      function calculateKIScores() {
        return Array.from({ length: 49 }, (_, i) => {
          const hotCold = hotColdMap[i] || { status: "neutral", count: 0 };
          const hotColdFactor = {
            hot: 1.1,
            cold: 0.85,
            neutral: 1.0
          }[hotCold.status];
          const transitions = Array.isArray(transitionMatrix[i]) ? transitionMatrix[i] : [];
          const transitionBonus = transitions.reduce((a, b) => a + b, 0) / 10;
          const chiFactor = chiSquareResult > 65 ? 1.1 : 1.0;
          const entropyFactor = 1.0;
          const f = hotCold.count || 0;
          return {
            number: i + 1,
            score: f * hotColdFactor * chiFactor * entropyFactor + transitionBonus
          };
        });
      }
      function renderKIVorhersage(freqs, entropy) {
        const scores = calculateKIScores();
        const top = scores.sort((a, b) => b.score - a.score).slice(0, 6);
        const el = document.getElementById('kiTopNumbers');
        el.innerHTML = top.map(n => `<span class="number">${n.number}</span>`).join('');
      }

      // --- Restlicher Analyse-/Backtest-Code (unverändert) ---
      function ermittleDieterPrognose(basisEntries = allLottoEntries) {
        updateDieterWeightsFromUI();
        function defizitArray(entries) {
          const freq = Array(49).fill(0);
          entries.forEach(e => e.Lottozahl?.forEach(z => freq[parseInt(z) - 1]++));
          return freq;
        }
        const alle = basisEntries;
        const letzte1000 = DIETER_BEREICH_1000 > 0 ? basisEntries.slice(-DIETER_BEREICH_1000) : null;
        const letzte100  = DIETER_BEREICH_100  > 0 ? basisEntries.slice(-DIETER_BEREICH_100 ) : null;
        const letzte25   = DIETER_BEREICH_25   > 0 ? basisEntries.slice(-DIETER_BEREICH_25  ) : null;
        const ziehungen_all   = alle.length * 6;
        const ziehungen_1000  = letzte1000 ? letzte1000.length * 6 : 0;
        const ziehungen_100   = letzte100  ? letzte100.length * 6  : 0;
        const ziehungen_25    = letzte25   ? letzte25.length * 6   : 0;
        const def_all   = defizitArray(alle).map(c => ziehungen_all/49   - c);
        const def_1000  = letzte1000 ? defizitArray(letzte1000).map(c => ziehungen_1000/49 - c) : Array(49).fill(0);
        const def_100   = letzte100  ? defizitArray(letzte100 ).map(c => ziehungen_100/49  - c) : Array(49).fill(0);
        const def_25    = letzte25   ? defizitArray(letzte25  ).map(c => ziehungen_25/49   - c) : Array(49).fill(0);

        const kombiScore = Array(49).fill(0).map((_, i) =>
          DIETER_WEIGHT_LONG  * def_all[i] +
          (DIETER_BEREICH_1000 > 0 && DIETER_WEIGHT_1000 > 0 ? DIETER_WEIGHT_1000 * def_1000[i] : 0) +
          (DIETER_BEREICH_100  > 0 && DIETER_WEIGHT_100  > 0 ? DIETER_WEIGHT_100  * def_100[i]  : 0) +
          (DIETER_BEREICH_25   > 0 && DIETER_WEIGHT_25   > 0 ? DIETER_WEIGHT_25   * def_25[i]   : 0)
        );
        const kiScores = calculateKIScores();
        const bewertet = kombiScore.map((defi, i) => ({
          zahl: i + 1,
          score: defi * (kiScores[i]?.score || 1)
        }));
        const top6 = bewertet.sort((a, b) => b.score - a.score).slice(0, 6);
        return top6.map(e => e.zahl);
      }
      function renderFreqChart(freqs, id, label, max, isSuper = false) {
        const ctx = document.getElementById(id)?.getContext('2d');
        if (!ctx) return;
        if (chartInstances[id]) chartInstances[id].destroy();
        const labels = Array.from({ length: max }, (_, i) => isSuper ? i : i + 1);
        chartInstances[id] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label, data: freqs,
              backgroundColor: '#4CAF50',
              borderColor: '#388E3C',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              y: { beginAtZero: true },
              x: { title: { display: true, text: label } }
            }
          }
        });
      }
      function renderTransitionHeatmap() {
        const ctx = document.getElementById('transitionHeatmap')?.getContext('2d');
        if (!ctx) return;
        if (chartInstances.transitionHeatmap) chartInstances.transitionHeatmap.destroy();
        const matrixData = transitionMatrix.flatMap((row, x) =>
          row.map((val, y) => ({ x, y, v: val }))
        );
        chartInstances.transitionHeatmap = new Chart(ctx, {
          type: 'matrix',
          data: {
            datasets: [{
              label: 'Heatmap',
              data: matrixData,
              width: 10,
              height: 10,
              backgroundColor: ctx => {
                const v = ctx.raw.v;
                const alpha = Math.min(v / 10, 0.9);
                return `rgba(255, 68, 68, ${alpha})`;
              }
            }]
          },
          options: {
            plugins: {
              tooltip: {
                callbacks: {
                  title: ctx => `Von ${ctx[0].raw.x + 1} zu ${ctx[0].raw.y + 1}`,
                  label: ctx => `Häufigkeit: ${ctx.raw.v}`
                }
              }
            }
          }
        });
      }
      function renderTopLottozahlen(arr) {
        const el = document.getElementById('topLottozahlenList');
        el.innerHTML = arr.map(n => `<span class="number">${n.number}</span>`).join('');
      }
      function renderTopSuperzahl(arr) {
        const el = document.getElementById('topSuperzahlList');
        el.innerHTML = arr.length
          ? `<span class="number superzahl-display">${arr[0].number}</span>`
          : "Keine Daten";
      }
      function getDatensatzSubset() {
        const select = document.getElementById('dataSubsetSelect');
        const value = select.value;
        if (value === 'all') return [...allLottoEntries];
        const count = parseInt(value);
        return allLottoEntries.slice(-count);
      }
      function performAnalysis() {
        updateDieterWeightsFromUI();
        const daten = getDatensatzSubset();
        const lottoFreqs = Array(49).fill(0);
        const superFreqs = Array(10).fill(0);
        const superStart = new Date(1991, 11, 7);

        daten.forEach(e => {
          if (Array.isArray(e.Lottozahl)) {
            e.Lottozahl.forEach(n => {
              const z = parseInt(n);
              if (z >= 1 && z <= 49) lottoFreqs[z - 1]++;
            });
          }
          if (e.Superzahl != null && e.date) {
            const [d, m, y] = e.date.split('.');
            const date = new Date(+y, m - 1, +d);
            if (date >= superStart) {
              const sz = parseInt(e.Superzahl);
              if (sz >= 0 && sz <= 9) superFreqs[sz]++;
            }
          }
        });

        const entropy = computeEntropy(lottoFreqs);
        renderHotColdNumbers(lottoFreqs);
        calculateTransitionMatrix(daten);
        calculateChiSquare(lottoFreqs);
        renderChiSquareResult();
        renderKIVorhersage(lottoFreqs, entropy);
        const top6 = ermittleDieterPrognose(daten);
        const el = document.getElementById("dieterPrognoseList");
        el.innerHTML = top6.map(e => `<span class="number">${e}</span>`).join('');
        renderFreqChart(lottoFreqs, 'freqChart', 'Lottozahlen 1–49', 49);
        renderEntropyGauge(entropy);
        renderFreqChart(superFreqs, 'superzahlFreqChart', 'Superzahlen 0–9', 10, true);
        renderTopLottozahlen(getTopNumbers(lottoFreqs, 6));
        renderTopSuperzahl(getTopNumbers(superFreqs, 1, true));
        renderTransitionHeatmap();
        updateZiehungsAnzeigen();
      }

      function runDieterBacktest(onlyStats=false, _wLong, _w1000, _w100, _w25) {
        updateDieterWeightsFromUI();
        const N = 50;
        const minData = Math.max(DIETER_BEREICH_1000, DIETER_BEREICH_100, DIETER_BEREICH_25, 1000);
        if (!allLottoEntries || allLottoEntries.length < N + minData) {
          if(!onlyStats) document.getElementById('dieterBacktestResults').innerHTML = "Nicht genug Daten für Backtest!";
          return onlyStats ? {schnitt:0, trefferStat:[0,0,0,0,0,0,0]} : undefined;
        }
        let origW = [DIETER_WEIGHT_LONG, DIETER_WEIGHT_1000, DIETER_WEIGHT_100, DIETER_WEIGHT_25, DIETER_BEREICH_1000, DIETER_BEREICH_100, DIETER_BEREICH_25];
        if (_wLong!==undefined) {
          DIETER_WEIGHT_LONG  = _wLong;
          DIETER_WEIGHT_1000  = _w1000;
          DIETER_WEIGHT_100   = _w100;
          DIETER_WEIGHT_25    = _w25;
        } else {
          updateDieterWeightsFromUI();
        }
        let trefferStat = [0, 0, 0, 0, 0, 0, 0];
        let detailRows = "";
        for (let i = allLottoEntries.length - N; i < allLottoEntries.length; i++) {
          const vergangene = allLottoEntries.slice(0, i);
          hotColdMap = classifyHotColdNumbers(Array(49).fill(0).map((_, idx) => vergangene.reduce((s, e) =>
            s+(Array.isArray(e.Lottozahl) && e.Lottozahl.map(Number).includes(idx+1)?1:0), 0)));
          calculateTransitionMatrix(vergangene);
          calculateChiSquare(Array(49).fill(0).map((_, idx) => vergangene.reduce((s, e) =>
            s+(Array.isArray(e.Lottozahl) && e.Lottozahl.map(Number).includes(idx+1)?1:0), 0)));
          const prognose = ermittleDieterPrognose(vergangene);
          const gezogen = allLottoEntries[i].Lottozahl.map(Number);
          let richtig = prognose.filter(z => gezogen.includes(z)).length;
          trefferStat[richtig]++;
          if(!onlyStats) {
            detailRows += `
              <tr>
                <td>${i+1}</td>
                <td>${gezogen.map(n=>`<span class="number">${n}</span>`).join(' ')}</td>
                <td>${prognose.map(n=>`<span class="number">${n}</span>`).join(' ')}</td>
                <td class="${richtig===0?'zero':'right'}">${richtig}</td>
              </tr>
            `;
          }
        }
        const trefferSchnitt = (trefferStat.reduce((s,c,i)=>s+c*i,0) / N);
        if (_wLong!==undefined) {
          [DIETER_WEIGHT_LONG, DIETER_WEIGHT_1000, DIETER_WEIGHT_100, DIETER_WEIGHT_25, DIETER_BEREICH_1000, DIETER_BEREICH_100, DIETER_BEREICH_25] = origW;
        }
        if(onlyStats) return {schnitt:trefferSchnitt, trefferStat};
        let statZeile = "";
        for (let i = 0; i <= 6; i++) {
          statZeile += `<td>${trefferStat[i]}</td>`;
        }
        document.getElementById('dieterBacktestResults').innerHTML = `
          <strong>Durchschnittliche Trefferzahl pro Ziehung: ${trefferSchnitt.toFixed(2)}</strong>
          <br>
          <table>
            <tr>
              <th colspan="7">Häufigkeit der Treffer (0 bis 6 Richtige)</th>
            </tr>
            <tr>
              <th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th>
            </tr>
            <tr>${statZeile}</tr>
          </table>
          <details style="margin-top:8px;">
            <summary>Details zu jeder Ziehung anzeigen</summary>
            <table>
              <tr>
                <th>#</th>
                <th>Gezogen</th>
                <th>Prognose</th>
                <th>Richtig</th>
              </tr>
              ${detailRows}
            </table>
          </details>
        `;
        updateZiehungsAnzeigen();
      }
    </script>
  </div>
</body>
</html>
