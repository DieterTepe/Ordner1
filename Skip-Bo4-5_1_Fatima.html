<!DOCTYPE html>

<!--
 - neust Version: 4.5.2
 - Aktuelle Werte aus dem Originalcode (Stand 19. April 2025)
 - Neue Werte basierend auf der Stockpriorität und Gegnerabwehr
 - Optimierung der Spielmechanik und KI-Strategie
 - ### **1. CSS-Erweiterungen**, # **2. initGame()** überarbeitet:
 - ### **3. handleDiscardPileDrop()** überarbeitet:
 - ### **4. evaluateMoveCandidates()** überarbeitet:
 - ### **5. Neue Hilfsfunktionen**
 - function predictEnemyStock(opponent), 
 - function detectConsecutiveDiscards(player)
 - function calculateDynamicPriorities()
 - **Einbauort:** Am Ende der bestehenden Hilfsfunktionen
 - ### **6. aiTurn()** überarbeitet
 - ### **7. executeStockAttack()** neue Funktion;
 - async function executeStockAttack(targetValue)
 - **Einbauort:** Nach der `aiTurn()`-Funktion
*** OPTIMIERUNG in Version 4.0.1 Nagelanpassung 
 - Nagel1, Nagel2, Nagel6, Nagel10/11, Nagel25 und Nagel40
 - Neuer  * 🟢 ("Nagel44“): Zusätzlicher adaptiver 
   Blockadeparameter Vorteil: Erhöht den Malus, wenn der 
   Gegner nur wenige Karten im Stock hat. Dies zwingt den 
   Gegner in kritischen Phasen zu weniger optimalen Zügen.
 - Neue 4.02 Nagelwerte angepasst 📌 NAGEL6:, 📌 NAGEL40:,
   📌 NAGEL1:, 📌 NAGEL7:, 📌 NAGEL34:, 📌 NAGEL14 ,
:  📌 NAGEL20:, 📌 NAGEL15:, 📌 NAGEL44: und 📌 NAGE2:
 - == ANPASSUNGEN Skip-Bo4-0-3 FÜR BLOCKADE-RESISTENZ ====
 -  Ziele: 
 -  1. KI priorisiert eigenen Stockabbau trotz Gegnerblockaden
 -  2. Erhöhte Joker-Effizienz gegen Blockaden
 -  3. Dynamische Anpassung an Gegnerstrategien
 -  4. Reduktion von Gegnerhilfe durch Ablagen
 -      Anpassung Version: 4.0.3  Nägel1, 7, 20, 24, 37, 40, 44,
 -      Nagel37 zusätzlich Fehlerbehebung bei ungültigen Aufrufen
 -     Anpassungen Version 4.5:
 -      neue function canRemoveStockCard() Stockabbau prüfen
 -      neu Grundversion Nägel angepasst Deburging Steuerung 
        intregiert so daß die Ausgaben mit true und false gesetzt
        werden können const nagel_deburg = {
 - 5. Nagel40 Fehler behoben Nagel14/20 Gegnerhilfe um 50% 
        reduzieren Stockabbau, 6/34 Stock-Bons, Stockabbau +40% 
        beschleunigen. (Nagel25/33) Joker-Reserve für Stockwerte >8 
        erzwingen Eingesetzt in Version 4.5.1

Hauptfunktionen:
------------------------------
1. initGame():
   - Initialisiert Spiel: Mischt Karten, verteilt an Spieler, setzt Felder zurück
   - Lädt Spielgeschwindigkeit/Name aus LocalStorage
   - Zeigt Regel-Overlay mit adaptivem Geschwindigkeitsregler (4.5.2 Feature)
   - Initialisiert KI-Tracking Variablen für Stockvorhersagen

2. updateView():
   - Aktualisiert UI mit 3D-Karteneffekten und Stock-Zahlenanzeigen
   - Integriert animierte Stock-Rahmen für aktuellen Spieler (Nagel44)
   - Verwendet preserve-3d CSS für realistische Kartenrotation

Spielsteuerung:
------------------------------
3. handleCardSelect(event):
   - Verarbeitet Kartenauswahl mit Touch/Click-Unterstützung
   - Markiert Karten mit Neon-Puls-Effekt und 40px Erhebung
   - Berücksichtigt Nagel47 (Stock-Hand-Karten-Kollisionsprüfung)

4. handleCardPlace(event):
   - Prüft Legality mit erweiterten Nagel-Regeln (v4.5.1)
   - Verhindert Stock-Ablagen durch neue Validierung
   - Integriert adaptive Blockadelogik (Nagel37/44)

5. drawCardsUntilFive(player):
   - Zieht Karten mit Face-Up/Unterschied für KI/Spieler
   - Verwendet Fisher-Yates für Nachziehstapel

6. switchPlayer():
   - Steuert KI-Zug mit 3s Verzögerung
   - Aktiviert Touch-Events nach Spielerwechsel
   - Zeigt KI-Analyse-Overlays während des Zuges

Spielmechanik:
------------------------------
7. isValidBuildMove(card, buildPileIndex):
   - Prüft Joker-Wert mit getJokerValue()
   - Berücksichtigt Stock-Angriffsstrategien (Nagel34)

8. isBuildPileComplete(buildPileIndex):
   - Erkennt 12er Sequenzen mit Joker-Integration
   - Prüft Stockabbau-Priorität via canRemoveStockCard()

9. clearBuildPile(buildPileIndex):
   - Mischt komplette Stapel zurück mit Shuffle-Animation
   - Aktiviert Joker-Reserve bei Stock >8 (Nagel25)

10. checkForWinner():
    - Prüft Stockstapel mit 5-Punkte-pro-Karte-Berechnung
    - Zeigt detaillierte Endanalyse mit Debug-Daten

Interaktion & UI:
------------------------------
11. showEndGameMessage():
    - Zeigt Overlay mit KI-Analyse und Exportfunktion
    - Inkludiert Stockabbau-Statistiken und Nagel-Performance

12. showInfoWindow():
    - Dynamische Tabellenansicht für Ablagestapel
    - 5s Auto-Hide mit Touch-Optimierung

13. setupTouchEvents():
    - Kombiniert Touch/Click-Handler mit Prevention
    - Integriert Long-Press-Erkennung (5s für Overlay)

14. enableDraggableStatusLabel():
    - Ermöglicht Statuslabel-Verschiebung mit Bounce-Effekt
    - CSS-Transitions für flüssige Animation

15. showOverlay():
    - Dynamisches CSS-Injection für Gradient Borders
    - Responsive Slider mit 0-20s Geschwindigkeitsbereich

KI-Logik (v4.5.2):
------------------------------
25. aiTurn():
    - Nutzt predictiveStockAnalysis für Zugplanung
    - Kombiniert Stock-Angriffe (executeStockAttack)
    - Adaptive Joker-Strategie mit Nagel40-44 Parametern
    - Verwendet discardTracking für Gegnerprognose

26. evaluateMoveCandidates():
    - Dynamische Scoring-Engine mit 50+ Nagel-Parametern
    - Berücksichtigt Stockdruck, Sequenzlücken, Joker-Future-Value
    - Integriert KI-Strategietags für visuelles Feedback

27. playInDiscardPiles():
    - Strategische Ablage mit Stock-Help-Boni (Nagel17a)
    - Vermeidet Gegnerhilfe durch Nagel20-Strafen

28. executeStockAttack():
    - Gezielte Angriffe auf gegnerische Stockwerte
    - Nutzt KI-Tracking-Daten für Vorhersagen

29. predictEnemyStock():
    - Deckkompositionsanalyse mit Wahrscheinlichkeiten
    - Berücksichtigt sichtbare Karten und Discard-History

Hilfsfunktionen (Neu v4.5):
------------------------------
30. applyStockFieldBorders():
    - Animierte Regenbogenrahmen für aktiven Spieler
    - CSS-Keyframe-Animation mit Hue-Rotation

31. calculateDynamicPriorities():
    - Phase-basierte Risikoberechnung
    - Stockangriffs-Gewichtung abhängig von Spielphase

32. detectConsecutiveDiscards():
    - Mustererkennung für Ablagesequenzen
    - Identifiziert 3er-Serien für Blockaden

33. trackGameObservations():
    - Sammelt Debug-Daten für KI-Analyse
    - Exportiert Ergebnisse als UTF-8 mit BOM

34. addStockHighlightStyles():
    - Dynamische CSS-Injection für Stock-Effekte
    - 1s Blink-Animation mit linear-gradient Borders

35. adjustLayoutForPortrait():
    - Responsive Skalierung für Mobile
    - 90vh-Container mit Touch-Optimierung

Optimierungen v4.5.2:
------------------------------
- Nagel44: Adaptiver Blockadeparameter mit sqrt-Berechnung
- Nagel37: Stockabbau-Priorisierung trotz Blockaden
- Nagel40: Dynamische Joker-Schwellenwerte
- Nagel47: Hand/Stock-Kollisionsvermeidung
- Deburging-System mit nagel_deburg-Objekt
- Fehler Anfang in mehreren Fuktilionen erweitert 
- Da der Joker ursprünglichen nicht für die Ablagekarten 
  vorgesehen waren müsten einige zusätzliche globale Variablen 
  und Nägel zum regeln eingefügt werden. Nagel39, 49, 51.
  Es muss noch festgestellt werden wie hoch beim Joker erkennen
  der Score* genommen wird um den Joker optimal zu nutzen.
  momentan * 13 Auch bei den neuen Nägel gibt es momentan 
  nur Schätzwert für den Schore 
- Es ist geplant 10 Spiele zu spielen um dann die einzelnen Nägel
  zu optimieren. 

-->

<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Skip-Bo Mobile</title>
    <style>

/* BASIS-STYLING */
body {
    margin: 0;
    padding: 0;
    background: #1B5E20;
    color: white;
    font-family: Arial, sans-serif;
}

/* Sicherstellen, dass html und body den ganzen Viewport einnehmen */
html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
}

/* Der Container für das Spiel */
.game-container {
    width: 100%;
    height: 600px; /* Design-Höhe: passe diesen Wert an, falls erforderlich */
    background: transparent; /* Nutze transparent, damit der Body-Hintergrund sichtbar bleibt */
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
}

#status-label {
    position: sticky;
    top: env(safe-area-inset-top); /* Statusleiste unter der Suchleiste */
    background: #2E7D32;
    padding: 10px;
    text-align: center;
    font-size: 1rem;
    z-index: 1000;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3); /* Schatteneffekt für den Statuslabel */
}

.game-container {
  height: 100dvh; /* Dynamische Viewport-Höhe statt 100vh */
  padding-top: env(safe-area-inset-top); /* Safe Area für iOS-Notch */
  box-sizing: border-box; /* Padding in der Höhe berücksichtigen */
  overflow-y: auto; /* Scrollen falls nötig */
}

.opponent-area {
    flex: 0 0 22%;
    padding: 10px;
    margin-bottom: 5px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.build-area {
    flex: 1;
    margin: 5px 0;
    padding: 0 10px;
    border-top: 15px solid transparent;
}

.human-area {
    flex: 0 0 22%;
    padding: 10px;
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.main-piles, .hand {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 8px;
    height: 15vh;
}

/* KARTENSTYLING */
.field {
    background: rgba(255,255,255,0.1);
    border: 2px dashed #fff;
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    perspective: 1000px; /* Perspektive hinzufügen für 3D-Effekte */
}

.card {
    border: 2px solid #000 !important;
    border-radius: 8px;
    aspect-ratio: 2/3; /* Standard-Kartenverhältnis */
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 5px;
    position: relative;
    transform-style: preserve-3d; /* 3D-Transformationsstil */
    transition: transform 0.5s, box-shadow 0.5s; /* Übergang für Transformationen */
    border: 2px solid #FFFFFF; /* Weißer äußerer Rand */
    box-shadow: 0 0 5px #000000, 0 0 15px #000000 inset; /* Doppelte Schatten */
    background: radial-gradient(circle, rgba(255,255,255,0.1), rgba(255,255,255,0.8)); /* Glanzeffekt */
}

.card.selected {
    transform: translateY(-40px) rotateY(15deg) rotateX(10deg); /* 3D-Rotation und höhere Erhebung bei Auswahl */
    animation: neon-pulse 1.5s infinite alternate, card-float 2s infinite; /* Animierter Leuchteffekt und höheres Schweben */
}

/* Rückseite der Karte */
.card.backface {
    background: lightgreen !important; /* Hellgrüner Hintergrund für alle Rückseiten */
    animation: card-glow 2s ease-in-out infinite alternate;
}

.card.backface::before {
    content: "SKIP-BO";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-45deg);
    font-size: 1.5rem;
    font-weight: bold;
    color: rgba(255,255,255,0.8);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    letter-spacing: 2px;
}

/* Ecken der Karte */
.card-corner {
    position: absolute;
    font-size: 1.2rem;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.card-corner.top-left { top: 5px; left: 5px; }
.card-corner.top-right { top: 5px; right: 5px; }
.card-corner.bottom-left {
    bottom: 5px;
    left: 5px;
    transform: rotate(180deg);
}
.card-corner.bottom-right {
    bottom: 5px;
    right: 5px;
    transform: rotate(180deg);
}

/* Mitte der Karte */
.card-middle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2rem;
    font-weight: bold;
    text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);
}

/* Karten in Spielfeld */
.field.card {
    width: 100%;
    aspect-ratio: 2/3;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    padding: 5px;
    position: relative;
}

/* Stellt sicher, dass die Karten im Stock- und Nachziehstapel dieselbe Größe wie Handkarten haben */
.human-area .field.stock .card,
.opponent-area .field.stock .card,
.build-area .field.draw-pile .card {
    width: 100%;
    height: 100%;
}

/* Kartenfarben nach Wert */
.card:not(.backface)[data-value="1"], .card:not(.backface)[data-value="2"],
.card:not(.backface)[data-value="3"], .card:not(.backface)[data-value="4"] {
    background: radial-gradient(circle, #BBDEFB, #64B5F6, #2196F3, #0D47A1) !important;
    box-shadow: 0 0 15px #2196F3; /* Neon-Effekt */
}
.card:not(.backface)[data-value="5"], .card:not(.backface)[data-value="6"],
.card:not(.backface)[data-value="7"], .card:not(.backface)[data-value="8"] {
    background: radial-gradient(circle, #C8E6C9, #81C784, #4CAF50, #1B5E20) !important;
    box-shadow: 0 0 15px #4CAF50; /* Neon-Effekt */
}
.card:not(.backface)[data-value="9"], .card:not(.backface)[data-value="10"],
.card:not(.backface)[data-value="11"], .card:not(.backface)[data-value="12"] {
    background: radial-gradient(circle, #FFCDD2, #EF9A9A, #f44336, #B71C1C) !important;
    box-shadow: 0 0 15px #f44336; /* Neon-Effekt */
}
.card:not(.backface)[data-type="joker"] {
    background: radial-gradient(circle, #FFF9C4, yellow, gold, #FFD700) !important;
    color: #000;
    box-shadow: 0 0 15px gold; /* Neon-Effekt */
}

/* ANIMATIONEN */

/* Animation für Neon-Glühen */
@keyframes card-glow {
    from { box-shadow: 0 0 5px #1565C0; }
    to { box-shadow: 0 0 15px #0D47A1; }
}

/* Animation für Neon-Puls */
@keyframes neon-pulse {
    from { box-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700, 0 0 30px #FFD700, 0 0 40px #FFD700; }
    to { box-shadow: 0 0 20px #FFD700, 0 0 30px #FFD700, 0 0 40px #FFD700, 0 0 50px #FFD700; }
}

/* Animation für das Schweben der Karte */
@keyframes card-float {
    0% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
    100% { transform: translateY(0); }
}

/* Animation für das sanfte Ablegen der Karte */
@keyframes card-drop {
    0% { transform: translateY(-40px) rotateY(15deg) rotateX(10deg); }
    100% { transform: translateY(0) rotateY(0) rotateX(0); }
}

/* LABEL-STILE */
.field::after {
    content: attr(data-label);
    position: absolute;
    bottom: 4px;
    left: 2px;
    right: 2px;
    font-size: 0.65rem;
    color: rgba(255,255,255,0.9);
    text-align: center;
    padding: 2px;
    background: rgba(0,0,0,0.4);
    border-radius: 3px;
}

.field.card.selected {
    box-shadow: 0 0 15px #FFD700, 0 0 30px #FFD700 inset; /* Verstärkte Neon-Effekte und innerer Schatten */
    transform: translateY(-40px) rotateY(15deg) rotateX(10deg) scale(1.05);
    animation: neon-pulse 1.5s infinite alternate, card-float 2s infinite; /* Animierter Leuchteffekt und höheres Schweben */
    transition: all 0.3s ease;
}

/* Animationen für das Ablegen der Karte */
.field.card.placed {
    animation: card-drop 1s forwards; /* Langsames und sanftes Ablegen */
}

.field.card {
    transition: all 0.3s ease;
    touch-action: manipulation; /* Verbessert Touch-Handling */
}

.joker-number {
    position: absolute;
    top: 5px;  /* Statt bottom: 40% */
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.8em;
    color: black;
    background-color: rgba(255, 255, 255, 0.8); /* Optional: für bessere Lesbarkeit */
    padding: 1px 3px; /* Optional: etwas Abstand um die Zahl */
    border-radius: 2px; /* Optional: leicht abgerundete Ecken */
}

/* INFO-FENSTER */
#info-window {
    position: absolute;
    top: -300px; /* Platz für den Statuslabel */
    left: 50%;
    transform: translateX(-50%);
    background: #000; /* Schwarzer Hintergrund */
    color: white; /* Weiße Schrift */
    padding: 15px; /* Mehr Padding für bessere Lesbarkeit */
    text-align: center;
    font-size: 1.2rem; /* Größere Schrift */
    z-index: 1001;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Schatten für bessere Abgrenzung */
    width: 10%; /* Halb so breit wie der Statuslabel */
    max-width: 600px; /* Maximale Breite */
    display: none;
}

#info-table {
    width: 100%;
    border-collapse: collapse;
    margin: 0 auto;
}

#info-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: center;
    background: rgba(255, 255, 255, 0.1); /* Helle Hintergrund für die Zellen */
}

/* Stil für Stock-Zahlenanzeige (gleich wie Joker-Zahl) */
.stock-count {
  position: absolute;
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.8em;
  color: black;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 1px 3px;
  border-radius: 2px;
  z-index: 1;
}

/* Kommentare und Beispiele für Anpassungen */

/* 
Um die Dauer des Schwebeeffekts zu ändern, passe die Dauer in der Animation 'card-float' an:
@keyframes card-float {
    0% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
    100% { transform: translateY(0); }
}
Beispiel:
animation: card-float 3s infinite; 
(damit dauert das Schweben 3 Sekunden anstelle von 2 Sekunden)

Um die Dauer des Ablegens der Karte zu ändern, passe die Dauer in der Animation 'card-drop' an:
@keyframes card-drop {
    0% { transform: translateY(-40px) rotateY(15deg) rotateX(10deg); }
    100% { transform: translateY(0) rotateY(0) rotateX(0); }
}
Beispiel:
animation: card-drop 2s forwards; 
(damit dauert das Ablegen 2 Sekunden anstelle von 1 Sekunde)
*/

/* 
Um den Neon-Effekt der Kartenfarbe zu ändern, passe die Schattenwerte in den entsprechenden Klassen an:
.card:not(.backface)[data-value="1"], .card:not(.backface)[data-value="2"],
.card:not(.backface)[data-value="3"], .card:not(.backface)[data-value="4"] {
    background: radial-gradient(circle, #BBDEFB, #64B5F6, #2196F3, #0D47A1) !important;
    box-shadow: 0 0 15px #2196F3; /* Neon-Effekt */
}
Beispiel:
box-shadow: 0 0 20px #2196F3; 
(damit wird der Neon-Effekt verstärkt)
*/

/* 
Um den 3D-Rotationseffekt und die Erhebung bei Auswahl zu ändern, passe die Transformationswerte in der Klasse 'card.selected' an:
.card.selected {
    transform: translateY(-40px) rotateY(15deg) rotateX(10deg); 
    animation: neon-pulse 1.5s infinite alternate, card-float 2s infinite; 
}
Beispiel:
transform: translateY(-20px) rotateY(10deg) rotateX(5deg); 
(damit wird die Erhebung und Rotation reduziert)
*/

/* ===================== */
/* KI-Erweiterungen 4.0.0 */
/* ===================== */
.ai-prediction-overlay {
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  border: 2px solid #ff4444;
  border-radius: 8px;
  animation: prediction-pulse 1.8s ease-in-out infinite;
  pointer-events: none;
  z-index: 999;
  box-shadow: 0 0 12px rgba(255, 68, 68, 0.3);
}

@keyframes prediction-pulse {
  0% { opacity: 0.4; transform: scale(0.98); }
  50% { opacity: 0.9; transform: scale(1.02); }
  100% { opacity: 0.4; transform: scale(0.98); }
}

.strategy-tag {
  position: absolute;
  bottom: calc(100% + 5px);
  left: 50%;
  transform: translateX(-50%);
  background: rgba(40, 40, 40, 0.9);
  color: #fff;
  padding: 4px 12px;
  border-radius: 15px;
  font-size: 0.85em;
  font-weight: bold;
  white-space: nowrap;
  backdrop-filter: blur(2px);
  z-index: 1001;
  box-shadow: 0 3px 6px rgba(0,0,0,0.2);
}

    </style>

</head>
<body>
    <div id="status-label">🎮 Spielstart: Karten werden gemischt...</div>
    
    <div class="game-container">
        <!-- GEGNER -->
        <section class="opponent-area">
            <div class="main-piles">
                <div class="field stock" data-label="🗃️ Gegner Stock (20)"></div>
                <div class="field" data-label="🗑️ Ablage 1"></div>
                <div class="field" data-label="🗑️ Ablage 2"></div>
                <div class="field" data-label="🗑️ Ablage 3"></div>
                <div class="field" data-label="🗑️ Ablage 4"></div>



            </div>
            <div class="hand" id="opponentHand"></div>
        </section>
        <!-- MITTE -->
        <section class="build-area">
            <div class="main-piles">
                <div class="field draw-pile" data-label="🃏 Nachzieh- stapel"></div>
                <div class="field build-pile" data-label="▲ Bau 1 (1)"></div>
                <div class="field build-pile" data-label="▲ Bau 2 (1)"></div>
                <div class="field build-pile" data-label="▲ Bau 3 (1)"></div>
                <div class="field build-pile" data-label="▲ Bau 4 (1)"></div>
            </div>
        </section>
        <!-- SPIELER -->
        <section class="human-area">
            <div class="main-piles">
                <div class="field" data-label="🗑️ Ablage 1"></div>
                <div class="field" data-label="🗑️ Ablage 2"></div>
                <div class="field" data-label="🗑️ Ablage 3"></div>
                <div class="field" data-label="🗑️ Ablage 4"></div>
                <div class="field stock" data-label=" Spieler Stock (20)"></div>
            </div>
            <div class="hand" id="playerHand"></div>
        </section>
    </div>
<div id="info-window" style="display: none;">
    <table id="info-table">
        <!-- Karten werden hier dynamisch eingefügt -->
    </table>
</div>


<script>

// Globale Variablen für die Kartenauswahl
let selectedCard = null;
let selectedSource = null;
let selectedIndex = null;
let Joker_auf_Ablage = false;

// Globale Variable für den aktuellen Spieler
let currentPlayer = 'human';
// Globaler Spielername (Standardwert)
let playerName = 'Spieler';


let spielGeschwindigkeit = 4; // Standardwert (mittel)
let currentGameId = Date.now(); // Einzigartige ID für jedes Spiel
let debugInfo = []; // Temporäre Debug-Informationen pro Spiel


// Alternativen für verschiedene Geschwindigkeiten
const GESCHWINDIGKEIT = {
    schnell: 1,
    mittel: 4,
    langsam: 10
};

const nagel_deburg = {
 zeitintervall: true, 
  nagel_1: false,  nagel_2: false, nagel_3: false, nagel_4: false, nagel_5: false,
  nagel_6: false, nagel_7: false, nagel_8: false, nagel_9: false, nagel_10: false,
  nagel_11: false, nagel_12: false, nagel_13: false, nagel_14: false, nagel_15: false,
  nagel_16: false, nagel_17: false, nagel_18: false, nagel_19: false, nagel_20: false,
  nagel_21a: false, nagel_22: false, nagel_23: false, nagel_24: false, nagel_25: false,
  nagel_26: false, nagel_27: false, nagel_28: false, nagel_29: false, nagel_30: false,
  nagel_31: false, nagel_32: false, nagel_33: false, nagel_34: false, nagel_35: false,
  nagel_36: false, nagel_37: false, nagel_38: false, nagel_39: false, nagel_40: false,
  nagel_41: false, nagel_42: false, nagel_43: false, nagel_44: false, nagel_45: false, nagel_17a: false,
  nagel_46: false, nagel_47: false, nagel_48: false, nagel_49: false, nagel_50: false, nagel_51: false,
};


// Globale Game-Struktur
const Game = {
    deck: [], // Das vollständige Kartendeck
    players: {
        human: { hand: [], stock: [], discards: [[], [], [], []] }, // Menschlicher Spieler
        ai: { hand: [], stock: [], discards: [[], [], [], []] }     // KI-Spieler
    },
    buildPiles: [[], [], [], []], // Die vier Baukartenstapel
    drawPile: [] // Der Nachziehstapel
};


// Funktion zur Initialisierung des Spiels (vollständig überarbeitet)
async function initGame() {
    // 1. Gespeicherte Spielgeschwindigkeit aus localStorage laden (falls verfügbar)
    try {
        const savedSpeed = localStorage.getItem('skipbo-speed');
        if (savedSpeed) {
  if (nagel_deburg.zeitintervall) {
            spielGeschwindigkeit = parseInt(savedSpeed);
            debugInfo.push('Geladene Spielgeschwindigkeit:', spielGeschwindigkeit);
           }
        } else {
  if (nagel_deburg.zeitintervall) {
            debugInfo.push('Keine gespeicherte Geschwindigkeit gefunden - Standardwert verwendet');
           }
        }
    } catch (e) {
        console.error('Fehler beim Zugriff auf localStorage:', e);
    }

    // 2. Kartendeck erstellen
    Game.deck = [];
    
    // Zahlenkarten generieren (12 Stapel à 12 Karten)
    for (let s = 0; s < 12; s++) {
        for (let n = 1; n <= 12; n++) {
            Game.deck.push({ type: 'number', value: n });
        }
    }
    
    // Jokerkarten hinzufügen (12 Stück)
    for (let j = 0; j < 12; j++) {
        Game.deck.push({ type: 'joker', value: '★' });
    }

    // 3. Karten mischen (Fisher-Yates Algorithmus)
    for (let i = Game.deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [Game.deck[i], Game.deck[j]] = [Game.deck[j], Game.deck[i]];
    }

    // 4. Karten verteilen
    // Handkarten (5 pro Spieler)
    Game.players.human.hand = Game.deck.splice(0, 5);
    Game.players.ai.hand = Game.deck.splice(0, 5);
    
    // Stockkarten (20 pro Spieler)
    Game.players.human.stock = Game.deck.splice(0, 20);
    Game.players.ai.stock = Game.deck.splice(0, 20);
    
    // Restliche Karten werden Nachziehstapel
    Game.drawPile = Game.deck;

    // 5. Karten sichtbar/unsichtbar markieren
    Game.players.human.hand.forEach(card => card.faceUp = true);  // Mensch sieht Handkarten
    Game.players.ai.hand.forEach(card => card.faceUp = false);    // KI-Handkarten verdeckt

    // 6. Spieloberfläche aktualisieren
    updateView();

    // 7. Statusmeldung und Drag & Drop aktivieren
    showMessage('Spiel initialisiert. Du bist am Zug!');
    enableDraggableStatusLabel();

    // 8. Overlay beim Start anzeigen
    showOverlay();

    // 9. Touch-Events initialisieren
    setupTouchEvents();

    // 10. KI-Zug vorbereiten (falls KI beginnen soll)
    if (currentPlayer === 'ai') {
        setTimeout(aiTurn, 3000);
    }

    // >>>>>>>> NEUER CODE <<<<<<<<
    /* KI-Tracking Variablen */
    Game.tracking = {
        deckComposition: Array.from({ length: 12 }, (_, i) => 12)
            .concat(Array(12).fill('joker')),
        discardHistory: {
            human: { values: [], timestamps: [] },
            ai: { values: [], timestamps: [] }
        },
        stockPredictions: {
            human: { nextExpected: 1, confidence: 0 },
            ai: { nextExpected: 1, confidence: 0 }
        }
    };

    /* DOM-Cleanup */
    document.querySelectorAll('.strategy-tag, .ai-prediction-overlay').forEach(el => el.remove());
}


// Funktion: Verzögerung (Pause) mit setTimeout
function delayWithCallback(ms, callback) {
    setTimeout(callback, ms);
}

// Update-Funktion, um die Ansicht zu aktualisieren
/* Erweiterte updateView-Funktion, die nach den ursprünglichen Aktualisierungen
   den neuen Rahmen für die Stockfelder setzt.
   Es wird der originale Code komplett beibehalten und nur um den Aufruf 
   der neuen Funktion 'applyStockFieldBorders' erweitert. */
function updateView() {
    updateHand('human', document.getElementById('playerHand'));
    updateHand('ai', document.getElementById('opponentHand'));
    updateStock('human', document.querySelector('.human-area .field.stock'));
    updateStock('ai', document.querySelector('.opponent-area .field.stock'));
    updateDrawPile(document.querySelector('.build-area .field.draw-pile'));
    updateBuildPiles();
    updateDiscardPiles();
    // Neuer Aufruf: Setzt die Rahmen um die Stockfelder basierend auf dem aktiven Spieler
    applyStockFieldBorders();
}
  
// Direkt beim Laden werden die neuen CSS-Regeln hinzugefügt.
addStockHighlightStyles();


// Neue Funktion: Fügt zusätzliche CSS-Regeln hinzu, 
// um den blinkenden Rahmen (ebenso wie im Overlay) für die Stockfelder zu definieren.
// Das Original-CSS bleibt unverändert.
// Diese Funktion fügt dynamisch CSS-Regeln hinzu, um den Rahmen (Border) um die Stockfelder anzupassen.
// Neu: Der Rahmen soll nun halb so dick sein wie in der vorherigen Version.
// Ursprünglich war der Rahmen 9px breit; jetzt wird er auf 4.5px gesetzt.
// Die Animationsgeschwindigkeit bleibt unverändert (1s, 5-mal so schnell wie der ursprüngliche 5s-Effekt).
function addStockHighlightStyles() {
  const style = document.createElement('style');
  style.innerHTML = `
  /* CSS für den animierten (blinkenden) Rahmen des aktiven Spielers */
  .animated-stock-border {
      /* Rahmen jetzt 4.5px breit (halb so dick wie die bisherigen 9px) */
      border: 4.5px solid;
      /* Linearer Farbverlauf wie im Overlay */
      border-image: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet) 1;
      /* Animation: blinkActiveStock läuft 1s lang, was 5-mal so schnell ist wie der ursprüngliche Effekt */
      animation: blinkActiveStock 1s linear infinite;
      /* Gleiche Abrundung wie in den Originalelementen (8px) */
      border-radius: 8px;
  }
  
  /* CSS für einen statischen Rahmen bei inaktivem Spieler */
  .static-stock-border {
      border: 4.5px solid gray;
      border-radius: 8px;
  }
  
  /* Keyframes für den animierten Rahmen 
     Hier wird der Helligkeitseffekt für das Blinken festgelegt.
     Die Animationsgeschwindigkeit bleibt unverändert. */
  @keyframes blinkActiveStock {
     0% { filter: brightness(1); }
     50% { filter: brightness(1.5); }
     100% { filter: brightness(1); }
  }
  `;
  document.head.appendChild(style);
}


/* Neue Funktion: Setzt den Rahmen um das Stockfeld des aktiven Spielers (animiert)
   und um das Stockfeld des inaktiven Spielers (statisch).
   Die Funktion sucht die Stockfelder in den Bereichen '.human-area' und '.opponent-area'. */
function applyStockFieldBorders() {
  const humanStockField = document.querySelector('.human-area .field.stock');
  const aiStockField = document.querySelector('.opponent-area .field.stock');

  if (humanStockField && aiStockField) {
    // Vorherige Rahmen-Klassen entfernen
    humanStockField.classList.remove('animated-stock-border', 'static-stock-border');
    aiStockField.classList.remove('animated-stock-border', 'static-stock-border');

    // Je nach aktivem Spieler den passenden Rahmen setzen
    if (currentPlayer === 'human') {
      humanStockField.classList.add('animated-stock-border');
      aiStockField.classList.add('static-stock-border');
    } else if (currentPlayer === 'ai') {
      aiStockField.classList.add('animated-stock-border');
      humanStockField.classList.add('static-stock-border');
    }
  }
}
  

// ----------------- NEUE FUNKTIONEN UND EVENT LISTENER FÜR DAS OVERLAY -----------------
// Funktion zur dynamischen Erstellung zusätzlicher CSS für das Overlay
function addOverlayStyles() {
  const style = document.createElement('style');
  style.innerHTML = `
    /* Overlay Container (Höhe angepasst) */
    #overlay-container {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 65%; /* Ursprünglich 60% - jetzt 5% höher */
      background: linear-gradient(to bottom, #000, #777);
      border-radius: 15px;
      z-index: 2000;
      display: none;
      padding: 10px;
      border: 3px solid;
      border-image: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet) 1;
      animation: flashBorder 5s linear infinite;
    }
    
    @keyframes flashBorder {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    
    /* Overlay Header (unverändert) */
    #overlay-header {
      position: relative;
      height: 40px;
      margin-bottom: 10px;
    }
    
    #btn-uebernehmen {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 90px;
      height: 30px;
      background: blue;
      color: white;
      border: none;
      border-radius: 5px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    #btn-uebernehmen:active {
      transform: scale(0.95);
    }
    
    #btn-schliessen {
      position: absolute;
      top: 20px;
      right: 20px;
      height: 30px;
      width: auto;
      background: grey;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    
    #input-name {
      position: absolute;
      top: 20px;
      left: calc(20px + 90px + 10px);
      right: calc(20px + 70px + 10px);
      height: 20px;
      border-radius: 5px;
      border: 1px solid #ccc;
      padding: 5px;
    }
    
    /* Info Textfeld (Höhe angepasst) */
    #overlay-info {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 70%;
      bottom: 90px; /* Ursprünglich 10% - Platz für Slider geschaffen */
      background: #eee;
      color: black;
      overflow-y: auto;
      pInitialisiereadding: 10px;
      border-radius: 10px;
    }
    
    #overlay-info h1, #overlay-info h2, #overlay-info h3 {
      color: darkred;
    }
    #overlay-info p {
     /* color: black; */
color: darkblack;
      margin-bottom: 10px;
    }
    #overlay-info li {
      color: blue;
    }

    /* NEU: Slider-Bereich unten (20px Abstand zum Rand) */
    .speed-control-container {
      position: absolute;
      bottom: 20px;
      left: 5%;
      right: 5%;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
    }

#speed-value {
  width: 110px;
  text-align: center;
  margin-right: 10px; /* Verschiebt das Element nach links */
  transform: translateX(-10px); /* Präzise Positionskorrektur */
}

    .speed-label {
      font-size: 0.9rem;
      color: #fff;
      width: 110px;
      text-align: center;
    }

    .speed-slider {
      flex: 1;
      max-width: 180px;
      margin: 0 10px;
    }

    .speed-slider {
      -webkit-appearance: none;
      height: 6px;
      background: #ddd;
      border-radius: 3px;
      outline: none;
    }

    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #ffd700;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }
  `;
  document.head.appendChild(style);
}


// 2. OVERLAY-FUNKTION (showOverlay) 
function showOverlay() {
  addOverlayStyles();
  
  let overlay = document.getElementById('overlay-container');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'overlay-container';
    
    // VOLLSTÄNDIGES HTML MIT ALLEN ORIGINALELEMENTEN
    overlay.innerHTML = `
      <div id="overlay-header">
        <button id="btn-uebernehmen">Übernehmen</button>
        <input type="text" 
               id="input-name" 
               placeholder="Spielername"
               value="${playerName}">
        <button id="btn-schliessen">Schließen</button>
      </div>

      <div id="overlay-info">
        ${createInfoText()}
      </div>

      <div class="speed-control-container">
        <span class="speed-label">Geschwindigkeit (0-20s)</span>
        <input type="range" 
               class="speed-slider"
               id="speed-slider"
               min="0"
               max="20"
               value="${spielGeschwindigkeit}"
               step="1">
        <span class="speed-label" id="speed-value">${spielGeschwindigkeit}s</span>
      </div>
    `;

    document.body.appendChild(overlay);

    // EVENT-HANDLER FÜR ÜBERNEHMEN-BUTTON (Original + Erweiterung)
    document.getElementById('btn-uebernehmen').addEventListener('click', function() {
      // Originalname-Funktionalität
      const newName = document.getElementById('input-name').value.trim();
      if(newName) {
        playerName = newName;
        const stockField = document.querySelector('.human-area .field.stock');
        if(stockField) {
          stockField.setAttribute('data-label', ` ${newName} Stock (20)`);
        }
        showMessage(`Spielername geändert zu: ${newName}`);
      }

      // Neue Geschwindigkeitseinstellung
      spielGeschwindigkeit = parseInt(document.getElementById('speed-slider').value);
      try {
        localStorage.setItem('skipbo-speed', spielGeschwindigkeit);
      } catch(e) {
        debugInfo.push('LocalStorage ❌ nicht verfügbar');
      }

      hideOverlay();
    });

    // Slider-Update-Anzeige
    document.getElementById('speed-slider').addEventListener('input', function(e) {
      document.getElementById('speed-value').textContent = `${e.target.value}s`;
    });

    // Original Schließen-Button
    document.getElementById('btn-schliessen').addEventListener('click', hideOverlay);
  }
  
  // Initialwerte setzen
  document.getElementById('input-name').value = playerName;
  document.getElementById('speed-slider').value = spielGeschwindigkeit;
  document.getElementById('speed-value').textContent = `${spielGeschwindigkeit}s`;
  
  overlay.style.display = 'block';
}


// Funktion zum Ausblenden des Overlays
function hideOverlay() {
  const overlay = document.getElementById('overlay-container');
  if (overlay) {
    overlay.style.display = 'none';
  }
}


// Hilfsfunktion zum Generieren des Info-Textes (basierend auf dem ursprünglichen Kommentar)
function createInfoText() {
  return `
    <h2>Spielregeln und Benutzerinformationen</h2>
    <p><strong>1. Ziel des Spiels:</strong><br>
    - Das Hauptziel ist es, alle Karten aus deinem Stockstapel abzulegen, um das Spiel zu gewinnen.<br>
    - Du kannst Karten auf die Baukartenstapel in aufsteigender Reihenfolge von 1 bis 12 ablegen.<br>
    - Joker können jede Karte ersetzen und haben keinen festen Wert.</p>
    <p><strong>2. Kartentypen:</strong><br>
    - Zahlenkarten: Karten mit Werten von 1 bis 12.<br>
    - Joker: Kann jede Karte ersetzen und wird flexibel verwendet.</p>
    <p><strong>3. Kartenmengen:</strong><br>
    - Es gibt insgesamt 144 Zahlenkarten, aufgeteilt in 12 Stapel à 12 Karten pro Zahl.<br>
    - Zusätzlich gibt es 12 Jokerkarten.</p>
    <p><strong>4. Spielstart:</strong><br>
    - Jeder Spieler erhält zu Beginn 5 Karten in die Hand.<br>
    - Jeder Spieler erhält außerdem 20 Karten in seinen Stockstapel.<br>
    - Die restlichen Karten werden als Nachziehstapel verwendet.</p>
    <p><strong>5. Spielverlauf:</strong><br>
    - Spieler legen abwechselnd Karten auf Baukartenstapel oder Ablagestapel ab.<br>
    - Die Karten müssen in aufsteigender Reihenfolge auf die Baukartenstapel gelegt werden.<br>
    - Ein Joker kann jede Karte ersetzen und kann auf jeden Baukartenstapel gelegt werden.<br>
    - Wenn ein Baukartenstapel vollständig ist, wird er geleert und die Karten werden in den Nachziehstapel gemischt.<br>
    - Ziehe Karten vom Nachziehstapel, bis du 5 Karten in der Hand hast.<br>
    - Wenn du keine legalen Züge mehr machen kannst, lege eine Karte auf einen deiner Ablagestapel.<br>
    - Ein kurzes Drücken auf den Ablagestapel zeigt, wie die Karten abgelegt werden.</p>
    <p><strong>6. Spieleraktionen:</strong><br>
    - Wähle eine Karte aus deiner Hand, deinem Stockstapel oder deinem Ablagestapel aus, um sie zu spielen.<br>
    - Lege die ausgewählte Karte auf einen Baukartenstapel oder Ablagestapel.<br>
    - Verwende die touchstart- und click-Ereignisse, um Karten auszuwählen und zu legen.<br>
    - Langes Drücken eines Ablagestapels zeigt ein Hinweisfenster an, das die Karten im Stapel anzeigt.<br>
    - Die Info-Leiste kann verschoben werden, um sie beim Spielen optimal zu platzieren.</p>
    <p><strong>7. Anpassung der Spielgeschwindigkeit:</strong><br>
    - Die Geschwindigkeit des Spiels kann mit der Variablen spielGeschwindigkeit angepasst werden.<br>
    - Standardwert ist 4 (mittel). Mögliche Werte sind: 0 (sehr schnell) bis 20 (sehr langsam), einstellbar über den Slider im Overlay.</p>
    <p><strong>8. Endgame:</strong><br>
    - Das Spiel endet, wenn ein Spieler alle Karten aus seinem Stockstapel abgelegt hat.<br>
    - Der Spieler, der keine Karten mehr im Stockstapel hat, gewinnt das Spiel.<br>
    - Die Punkte des Verlierers werden basierend auf den verbleibenden Karten in der Hand berechnet (5 Punkte pro Karte).</p>
    <p><strong>9. Weitere Details:</strong><br>
    - Wenn der Nachziehstapel leer ist, werden alle vollständigen Baukartenstapel gemischt und als neuer Nachziehstapel verwendet.<br>
    - Spieler können nur eine Karte pro Zug legen, entweder auf einen Baukartenstapel oder einen Ablagestapel.<br>
    - Der aktuelle Spieler wird durch die switchPlayer-Funktion verwaltet, die zwischen human und ai wechselt.<br>
    - Die Stockkarten zeigen nun die verbleibende Anzahl der Karten an.<br>
    - Die Jokerkarte zeigt immer die ersetzte Karte an.<br>
    - Ein langes 5 Sekunden Drücken auf die HTML-Seite öffnet dieses Info-Fenster wieder.<br>
    - Und es kann in diesem Fenster unten am Slider die Spielgeschwindigkeit eingestellt werden.<br>
    - Im Hauptfenster kann man die Infoleiste nach unten schieben, um sie beim Spielen optimal zu platzieren.</p>
  `;
}


// Longdruck-Erkennung: Overlay anzeigen, wenn länger als 5 Sekunden gedrückt wird
(function addLongPressListener() {
  let pressTimer;
  document.addEventListener('touchstart', function(e) {
    pressTimer = setTimeout(showOverlay, 5000); // 5000ms = 5 Sekunden
  });
  document.addEventListener('touchend', function(e) {
    clearTimeout(pressTimer);
  });
  // Zusätzlich auch für Mausklicks (optional)
  document.addEventListener('mousedown', function(e) {
    pressTimer = setTimeout(showOverlay, 5000);
  });
  document.addEventListener('mouseup', function(e) {
    clearTimeout(pressTimer);
  });
})();

// ----------------- ENDE DER NEUEN FUNKTIONEN -----------------


// Touch-Event Handler hinzufügen
function setupTouchEvents() {
    // Alte Event-Listener entfernen
    document.querySelectorAll('.field.card, .build-pile, [data-label*="Ablage"]').forEach(element => {
        element.removeEventListener('touchstart', handleCardSelect);
        element.removeEventListener('touchstart', handleCardPlace);
        element.removeEventListener('click', handleCardSelect);
        element.removeEventListener('click', handleCardPlace);
    });
    
    // Neue Event-Listener hinzufügen
    document.querySelectorAll('.field.card').forEach(card => {
        card.addEventListener('touchstart', handleCardSelect);
        card.addEventListener('click', handleCardSelect);
    });
    // Event-Listener für Baustapel verbessert
    document.querySelectorAll('.build-pile, .build-pile .card').forEach(target => {
        target.addEventListener('touchstart', handleCardPlace);
        target.addEventListener('click', handleCardPlace);
    });
    // Event-Listener für Ablagestapel
    document.querySelectorAll('[data-label*="Ablage"]').forEach(target => {
        target.addEventListener('touchstart', handleCardPlace);
        target.addEventListener('click', handleCardPlace);
    });
}


// Funktion zum Auswählen einer Karte
function handleCardSelect(event) {
    event.preventDefault();
    
    // Vorherige Auswahl entfernen
    document.querySelectorAll('.selected').forEach(el => 
        el.classList.remove('selected'));
    
    const card = event.target.closest('.field.card');
    if (!card) return;
    
    // Auswahl markieren
    card.classList.add('selected');
    
    // Karteninformationen speichern
    selectedCard = {
        value: parseInt(card.dataset.value) || card.dataset.value,
        type: card.dataset.type
    };
    
    selectedSource = getSourceType(card);
    selectedIndex = getSourceIndex(card);
    
    showMessage('Karte ausgewählt - wählen Sie ein Zielfeld');
}


// Funktion zum Ablegen einer Karte
function handleCardPlace(event) {
    event.preventDefault();
    
    if (!selectedCard) {
        showMessage('Bitte zuerst eine Karte auswählen');
        return;
    }
    
    const target = event.target.closest('.build-pile') || 
                  event.target.closest('[data-label*="Ablage"]');
    if (!target) return;
    
    if (currentPlayer !== 'human') {
        showMessage('Es ist nicht dein Zug!');
        return;
    }
    
    let success = false;
    const wasLastHandCard = selectedSource === 'hand' && Game.players.human.hand.length === 1;
    
    // --- Einfügepunkt: Hinzufügen der neuen Bedingung ---
    // Neue Bedingung: Überprüfen, ob die ausgewählte Handkarte identisch mit der obersten Stockkarte ist (außer Joker)
    const stockPile = Game.players.human.stock;
    const topStock = stockPile[stockPile.length - 1];
   if (selectedCard === topStock && selectedCard.type !== 'joker') { // Änderung: Abbruch, wenn Handkarte der Stockkarte entspricht und kein Joker ist

if (nagel_deburg.nagel_47) {
        debugInfo.push(`📌47 Die Handkarte entspricht der Stockkarte und ist kein ★Joker weiter mit aiTurn❌ `);
}
        aiTurn();
        return;
    }
    // --- Ende der Einfügemarke ---
    
    if (target.classList.contains('build-pile') || target.closest('.build-pile')) {
        const buildPiles = document.querySelectorAll('.build-pile');
        const buildPileIndex = Array.from(buildPiles).indexOf(
            target.classList.contains('build-pile') ? target : target.closest('.build-pile')
        );
        
        if (handleBuildPileDrop(currentPlayer, selectedSource, selectedIndex, buildPileIndex)) {
            success = true;
            showMessage('Du hast eine Karte auf 🗑️Baustapel gelegt');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 Du hast eine Karte auf 🗑️Baustapel gelegt 🎲🎲 `);
  }
            
            // Nur neue Karten ziehen, wenn die letzte Handkarte auf einen Baustapel gelegt wurde
// dddd prüfen ob drawCardsUntilFive('human') auch gemacht wird !!
// drawCardsUntilFive('ai');

            if (wasLastHandCard) {
                drawCardsUntilFive('human');
drawCardsUntilFive('ai'); // zusätzlich eingefügt dddd
            }
        } else {
            showMessage('Dieser Zug ist nicht erlaubt');
        }
    } else if (target.matches('[data-label*="Ablage"]')) {
        const discardPiles = document.querySelectorAll(`.human-area [data-label*="Ablage"]`);
        const discardPileIndex = Array.from(discardPiles).indexOf(target);
        
        if (handleDiscardPileDrop(currentPlayer, selectedSource, selectedIndex, discardPileIndex)) {
            success = true;
            showMessage('Du hast eine Karte auf Ablagestapel gelegt');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 Du hast eine Karte auf Ablagestapel gelegt 🎲🎲  `);
  }
            switchPlayer(); // Spieler wechseln
            showMessage('Karte auf Ablagestapel gelegt, Spieler wechselt');
        }
    }
    
    if (success) {
        selectedCard = null;
        selectedSource = null;
        selectedIndex = null;
        
        document.querySelectorAll('.selected').forEach(el => 
            el.classList.remove('selected'));
        
        updateView();
        setupTouchEvents(); // Event-Listener neu hinzufügen
    }
}


// Funktion zum Erkennen der Kartenquelle
function getSourceType(element) {
    if (element.closest('.hand')) return 'hand';
    if (element.closest('.stock')) return 'stock';
    if (element.closest('[data-label*="Ablage"]')) return 'discard';
    return null;
}


// Funktion getSourceIndex
function getSourceIndex(element) {
    if (element.closest('.hand')) {
        return Array.from(element.parentElement.children).indexOf(element);
    }
    if (element.closest('[data-label*="Ablage"]')) {
        // Korrigierte Indizierung für Ablagestapel
        const discardPiles = document.querySelectorAll('.human-area [data-label*="Ablage"]');
        return Array.from(discardPiles).indexOf(element.closest('[data-label*="Ablage"]'));
    }

    return 0.01; // Für Stock    (0.01 um teilen durch null zu verhindern)  1 DieterFehler 
}


// Funktion getJokerValue
function getJokerValue(buildPile, jokerPosition) {
    // Wenn Joker erste Karte ist, repräsentiert er eine 1
    if (jokerPosition === 0) return 1;
    
    // Sonst ist der Wert die Position + 1 oder der Wert der vorherigen Karte + 1
    const previousCard = buildPile[jokerPosition - 1];
    if (previousCard.type === 'joker') {
        return jokerPosition + 1;
    } else {
        return parseInt(previousCard.value) + 1;
    }
}



// Funktion handleBuildPileDrop, welche beibehalten wird.
// Diese Funktion erlaubt es, Karten aus Hand, Stock oder Ablagestapel
// auf einen Baukartenstapel zu legen, mit erweiterten Debug-Informationen.
function handleBuildPileDrop(player, sourceType, sourceIndex, buildPileIndex) {
  let card; // Platzhalter für die Karte, die verschoben wird
  let sourceArray; // Array für die Quelle der Karte
  
  switch (sourceType) {
    case 'hand':
      // Zugriff auf die Handkarten des Spielers
      sourceArray = Game.players[player].hand;
      card = sourceArray[sourceIndex];
      break;
    case 'stock':
      // Zugriff auf den Stock des Spielers
      sourceArray = Game.players[player].stock;
      card = sourceArray[sourceArray.length - 1];
      break;
    case 'discard':
      // Korrekter Zugriff auf den Ablagestapel mit Index
      sourceArray = Game.players[player].discards[sourceIndex];
      if (sourceArray?.length > 0) {
        card = sourceArray[sourceArray.length - 1]; // Letzte Karte des Ablagestapels

if (nagel_deburg.nagel_46) {
        debugInfo.push(`📌46 Ablagestapel ${sourceIndex + 1}: ${card.value} gefunden`); // Debug-Information
}

      } else {

if (nagel_deburg.nagel_46) {
        debugInfo.push(`📌46 Ablagestapel ${sourceIndex + 1} ist leer`); // Debug-Information für leeren Stapel
}

        return false; // Keine Karte gefunden, Abbruch
      }
      break;
    default:

if (nagel_deburg.nagel_46) {
 debugInfo.push(`📌46 Ungültiger sourceType ❌ Abbruch in Ablagestapel ${sourceIndex + 1}:  gefunden`);
 debugInfo.push(`📌46 Keine Karte gefunden!  ❌ Abbruch Karte ${card} gefunden`);
}

      return false; // Ungültiger sourceType, Abbruch
  }

  if (!card) {
    return false; // Keine Karte gefunden, Abbruch
  }

  // Überprüfen, ob der Zug auf den Baukartenstapel gültig ist
  if (isValidBuildMove(card, buildPileIndex)) {
    // Karte zum Baukartenstapel hinzufügen
    Game.buildPiles[buildPileIndex].push(card);

    // Entfernen der Karte aus der Quelle
    if (sourceType === 'hand') {
      sourceArray.splice(sourceIndex, 1); // Karte aus der Hand entfernen
    } else {
      sourceArray.pop(); // Letzte Karte aus Stock oder Ablagestapel entfernen
    }

    // Prüfen, ob der Baukartenstapel vollständig ist
    if (isBuildPileComplete(buildPileIndex)) {
      clearBuildPile(buildPileIndex); // Stapel leeren, wenn vollständig
    }

    return true; // Zug erfolgreich
  }

  return false; // Ungültiger Zug, Abbruch
}




// Funktion handleDiscardPileDrop
// Funktion zum Ablegen einer Karte auf einen Ablagestapel
// Verarbeitet das Ablegen für menschliche Spieler und KI
// Neu: Beobachtung für Gegnerblockaden speichern, wenn der menschliche Spieler legt
// Anpassbar: 
// - Nachrichtentexte können geändert werden (z. B. mehr Details hinzufügen)
// - Beobachtungsdaten können erweitert werden (z. B. Ablagestapel-Index speichern)
function handleDiscardPileDrop(player, sourceType, sourceIndex, discardPileIndex) {
    // >>>>>>>> NEUER CODE <<<<<<<<
    // Überprüfung, ob eine Karte ausgewählt wurde.
    // Wichtig: Es muss wie hier in der Originalversion am Schluss immer eine Karte abgelegt werden.
    // Falls keine Karte ausgewählt wurde, wird als Fallback die am schlechtesten bewertete Karte aus der Hand gewählt.

if (!selectedCard) {
    if (Game.players[player].hand.length > 0) {
        // Strategische Bewertung jeder Handkarte
        const criticalNumbers = getOpponentCriticalNumbers(); // 🟢 Feindliche Stock/Ablage-Zahlen
        let safestIndex = 0;
        let lowestScore = Infinity;
        
        Game.players[player].hand.forEach((card, i) => {
            // Score-Berechnung (je niedriger = sicherer)
            let score = 0;
            
            // 1. Gefahr für Gegnerhilfe (Blockadewert + kritische Zahlen)
// 🟠 NAGEL37 (Kritische-Zahlen-Bonus) - Ursprünglicher Code: Ursprünglichen 1000
   score += criticalNumbers.includes(card.value + 1) ? 2500 : 0;  // * 🟢 ("Nagel37")
 if (nagel_deburg.nagel_37) {
//    debugInfo.push(`📌37 🔒Blockade score⬆️+2500 Gegnerhilfe ges.=🎉 ${score} `);
debugInfo.push(`📌37 🔒Blockade Karte: ${card.value} (${card.type}) Score⬆️+2500 Gegnerhilfe ges.=🎉 ${score}`);
  }

// Erklärung:
// - Bonus von 2500 (statt 1000) bei Blockade kritischer Zahlen
// - Dynamische Reduktion basierend auf Bau-Stapelhöhe → Fokus auf niedrige Stapel
            
            // 2. Nutzlosigkeit (Wert weit entfernt von KI-Stock)
            const stockTop = Game.players[player].stock.slice(-1)[0]?.value || 0;  // jetzt mit Fehler Prüfung 
     //       score += Math.abs(card.value - stockTop) * 10;  // 🟢 Distanz zum eigenen Stock // * 🟢 ("Nagel38") DieterFehler1 
try {
    // Berechnung des Wertes und Aktualisierung des Scores
    let calculatedValue = Math.abs(card.value - stockTop) * 10;
    
    // Überprüfen, ob der berechnete Wert gültig ist DieterFehler1
    if (!isNaN(calculatedValue) && isFinite(calculatedValue)) {
        score += calculatedValue; // Wert zum Score hinzufügen
    } else {
   //     console.warn("Ungültiger Wert berechnet: NaN oder unendlich. Score bleibt unverändert.");
debugInfo.push(`📌38 Distanz 🟢🟢Ungültiger Wert berechnet: NaN oder unendlich.🟢🟢 Score bleibt unverändert =🎉 ${score}`);
    }
} catch (error) {
    // Fehler abfangen und protokollieren
    console.error("Fehler bei der Berechnung des Scores:", error);
}


 if (nagel_deburg.nagel_38) {
//    debugInfo.push(`📌38 Distanz↔️ zum eigenen Stock Score-ges.=🎉 ${score} `);
debugInfo.push(`📌38 Distanz↔️ zum eigenen Stock: Karte: ${card.value} (Stock-Top: ${stockTop}) Score-ges.=🎉 ${score}`);
  }
            
            // 3. Joker-Schutz (Joker nur im Notfall ablegen)
 //           score += (card.type === 'joker') ? 500 : 0;  // * 🟢 ("Nagel33") jetzt mit Fehler Prüfung DieterFehler2

try {
    // Berechnung des Bonus-Wertes für Joker DieterFehler2
    let bonusValue = (card.type === 'joker') ? 500 : 0;

    // Überprüfen, ob der berechnete Wert gültig ist
    if (!isNaN(bonusValue) && isFinite(bonusValue)) {
        score += bonusValue; // Wert zum Score hinzufügen
    } else {
   //     console.warn("Ungültiger Bonus-Wert berechnet: NaN oder unendlich. Score bleibt unverändert.");
debugInfo.push(`📌33 Distanz 🟢🟢Ungültiger Bonus-Wert berechnet: NaN oder unendlich.🟢🟢 Score bleibt unverändert =🎉 ${score}`);
    }
} catch (error) {
    // Fehler abfangen und protokollieren
    console.error("Fehler bei der Berechnung des Joker-Bonus:", error);
}

 if (nagel_deburg.nagel_33) {
  //  debugInfo.push(`📌33  score⬆️+= 500 wenn Karte ★Joker★ nur im Notfall ablegen Score-ges.=🎉 ${score}  `);
debugInfo.push(`📌33 Joker-Schutz: Karte: ${card.value} (Typ: ${card.type}) Score⬆️+500 ges.=🎉 ${score}`);
  }
          
            // 4. Vermeidung von Sequenzlücken (z.B. 3 in Ablage, wenn 4 im Stock)
            score += getDiscardSequenceBonus(player, discardPileIndex, card);
            
            if (score < lowestScore) {
                lowestScore = score;
                safestIndex = i;
            }
        });
        
        selectedCard = Game.players[player].hand[safestIndex];
        showMessage(`Automatische Ablage: Unnötigste Karte (${selectedCard.value}) gewählt.`);

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 Automatische Ablage: Unnötigste Karte (${selectedCard.value}) gewählt. 🎲🎲 `);
  }

        } else {
            showMessage('Keine Karte verfügbar zum Ablegen.');
            return false;
        }
    }
    // >>>>>>>> ORIGINALCODE ANFANG <<<<<<<<
    let card;
    let sourceArray;
    switch (sourceType) {
        case 'hand':
            sourceArray = Game.players[player].hand;
            card = sourceArray[sourceIndex];
            break;
        case 'stock':
            // Verhindere das Ablegen von Stockkarten in die Ablage
            showMessage(`${player === 'human' ? 'Du' : 'KI'} kann keine Stockkarten in die Ablage legen.`);

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 ${player === 'human' ? 'Du' : 'KI'} kann keine Stockkarten in die Ablage legen. 🎲🎲 `);
  }

            return false;
        default:
            return false;
    }
    
    if (card) {
        // Stelle sicher, dass das Discards-Array initialisiert ist
        if (!Game.players[player].discards[discardPileIndex]) {
            Game.players[player].discards[discardPileIndex] = [];
        }
        
        // Füge die Karte zum Ablagestapel hinzu
        Game.players[player].discards[discardPileIndex].push(card);
        
        // Entferne die Karte von der Quelle
        if (sourceType === 'hand') {
            sourceArray.splice(sourceIndex, 1);
        } else {
            sourceArray.pop();
        }
        
        // Neu: Beobachtung speichern, wenn der menschliche Spieler legt
        // Dies hilft zu tracken, ob der Gegner die KI blockiert
        // Anpassbar: Füge weitere Daten hinzu, z. B. discardPileIndex, wenn du Ablagestapel analysieren willst
        if (player === 'human') {
            trackGameObservations('opponentDiscard', { cardValue: card.value });
        }
        
        // >>>>>>>> NEUER CODE <<<<<<<<
        /* Discard Tracking */
        try {
            // Erneuter Zugriff auf die Karte aus der entsprechenden Quelle
            const trackingCard = sourceType === 'hand' 
                ? Game.players[player].hand[sourceIndex]  // (Hinweis: Diese Zeile könnte veraltet sein, da die Karte bereits entfernt wurde)
                : Game.players[player].discards[discardPileIndex].slice(-1)[0];
            // Verwendung der bereits vorhandenen "card"-Variable für das Tracking:
            if (card?.value || card?.type === 'joker') {
                const key = card.type === 'joker' ? 'joker' : card.value;
                if (Game.tracking.deckComposition[key] > 0) {
                    Game.tracking.deckComposition[key]--;
                }
                Game.tracking.discardHistory[player].values.push(key);
                Game.tracking.discardHistory[player].timestamps.push(Date.now());
            }
        } catch (e) {
            console.error('Discard Tracking Error:', e);
        }
        // >>>>>>>> ORIGINALCODE ENDE <<<<<<<<
        
        // Final: Karte wurde abgelegt, daher Rückgabe true.

        return true;
    }
    
    showMessage(`${player === 'human' ? 'Du' : 'KI'} konnte keine Karte ablegen.`);
    return false;
}




// Funktion zur Nachziehung von Karten bis zu 5 Karten in der Hand
function drawCardsUntilFive(player) {
    while (Game.players[player].hand.length < 5 && Game.drawPile.length > 0) {
        const card = Game.drawPile.pop();
        card.faceUp = player === 'human'; // Karten für den Menschen sichtbar, für die KI verdeckt
        Game.players[player].hand.push(card);
    }
    updateView();
}



// NEUE FUNKTION (vor evaluateMoveCandidates einfügen)
function neededForStock(jokerValue) {
    /* Prüft, ob der Joker-Wert einer Stock-Karte entspricht */
    return Game.players.ai.stock.some(card => 
        card.type === 'number' && card.value === jokerValue
    );
}


// NEUE FUNKTION (vor evaluateMoveCandidates einfügen)
function getOpponentCriticalNumbers() {
    /* Gibt die Zahlen zurück, die der Gegner (Mensch) dringend benötigt
       - Oberste Stock-Karte des Gegners
       - Oberste Karten seiner Ablagestapel */
    const criticalNumbers = [];
    
    // Stock-Karte des Gegners
    const humanStock = Game.players.human.stock;
    if (humanStock.length > 0) {
        const topStockCard = humanStock[humanStock.length - 1];
        criticalNumbers.push(parseInt(topStockCard.value) + 1);
    }

    // Ablagestapel des Gegners
    Game.players.human.discards.forEach(pile => {
        if (pile.length > 0) {
            const topDiscard = pile[pile.length - 1];
            criticalNumbers.push(parseInt(topDiscard.value) + 1);
        }
    });

    return [...new Set(criticalNumbers)]; // Duplikate entfernen
}


// Wählt den besten Zug basierend auf der Bewertungsfunktion und führt ihn aus.
async function evaluateAndSelectMove(player) {
  const candidates = evaluateMoveCandidates(player);
  if (candidates.length === 0) return false;
  
  // Sortiere die Kandidaten absteigend nach Score und wähle den besten Zug.
  candidates.sort((a, b) => b.score - a.score);
  const bestCandidate = candidates[0];
  
  showMessage(`KI wählt Zug: Karte (${bestCandidate.card.value}) von ${bestCandidate.sourceType} für 🗑️Baustapel ${bestCandidate.buildPileIndex + 1} mit Score ${bestCandidate.score}.`);

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI wählt Zug: Karte (${bestCandidate.card.value}) von ${bestCandidate.sourceType} für 🗑️Baustapel ${bestCandidate.buildPileIndex + 1} mit Score ${bestCandidate.score}. 🎲🎲 `);
  }

  await pauseForSeconds();
  handleBuildPileDrop(player, bestCandidate.sourceType, bestCandidate.sourceIndex, bestCandidate.buildPileIndex);
  updateView();
  return true;
}



// Diese Funktion prüft, ob der Abbau einer Stockkarte möglich ist.
// Die konkrete Logik kann an die Spielbedingungen angepasst werden.
// Beispielhafte Implementierung: Es wird überprüft, ob das Spielobjekt existiert,
// ob der KI-Spieler und sein Stock vorhanden sind, ob der Stock nicht leer ist,
function canRemoveStockCard() {
  try {
//    debugInfo.push("📌39 🔍 canRemoveStockCard: Start");

    if (!Game || !Game.players || !Game.players.ai) {
//      debugInfo.push("📌39 ⛔ Game oder AI-Spieler fehlt");
      return false;
    }

    const stock = Game.players.ai.stock;
    if (!Array.isArray(stock) || stock.length === 0) {
 //     debugInfo.push("📌39 ⛔ Stock ungültig oder leer");
      return false;
    }

    const topCard = stock[stock.length - 1];
//    debugInfo.push(`📌39 🔎 topCard: ${JSON.stringify(topCard)}`);
    if (!topCard) {
//      debugInfo.push("📌39 ⛔ Keine TopCard vorhanden");
      return false;
    }

    if (!('value' in topCard)) {
 //     debugInfo.push("📌39 ⛔ TopCard hat kein 'value'-Feld");
      return false;
    }

    if (typeof topCard.removable === 'boolean' && !topCard.removable) {
//      debugInfo.push("📌39 ⛔ topCard.removable ist false");
      return false;
    }

    if (topCard.type === 'number') {
      const value = parseInt(topCard.value, 10);
//      debugInfo.push(`📌39 🔢 topCard.value = ${topCard.value}, parsed = ${value}`);
      if (isNaN(value) || value < 1 || value > 12) {
//        debugInfo.push(`📌39 ⛔ Ungültiger Zahlenwert: ${topCard.value}`);
        return false;
      }
    }

    if (typeof Game.stockCardIsRemovable === 'boolean' && Game.stockCardIsRemovable !== true) {
//      debugInfo.push("📌39 ⛔ globales stockCardIsRemovable ist false");
      return false;
    }

//    debugInfo.push("📌39 ✅ canRemoveStockCard: TRUE – Stockkarte ist abbaubar");
    return true;
  } catch (err) {
//    debugInfo.push(`📌39 ❌ Fehler in canRemoveStockCard: ${err.message}`);
    return false;
  }
}




/*********************************************
 * 🎭 VERBESSERTE JOKER-BEWERTUNG MIT NEUEN KONSTANTEN ("Nagel40"), ("Nagel41"), ("Nagel42") 🎭
 * 
 * Diese Funktion bewertet alle möglichen Züge (aus Hand, Stock und Ablage)
 * 
 * Feinabstimmung: Passe die Werte schrittweise an.
 *********************************************/
function evaluateMoveCandidates(player) {

 const humanStockPressure = Game.players.human.stock.length / 30;
 const remainingJokers = Game.tracking.deckComposition.joker || 0; 

// Neuer Code
// ============================================
// Um sicherzustellen, dass der Schwellenwert auf dem gewünschten,
// konservativeren Niveau von 0.25 liegt und die Probleme mit dem niedrigen
// Wert von 0.133... zu beheben, ersetze die dynamische Berechnung
// durch einen festen Wert. Dies vereinfacht das Tuning, opfert aber
// die Anpassung an die verbleibenden Joker und den Gegnerdruck.
// nagel40 wieder auf festen Wert da dynamisch nicht Erfolg verspricht 

const nagel40 = 0.25;
const nagel41 = 1500;          // Mindestbewertung bei nur Joker-Zügen
const nagel42 = 0.6;           // Joker-Gewichtung

 if (nagel_deburg.nagel_40) {
    debugInfo.push(`📌40 ★Joker-Schwellenwert ges.=🎉 ${nagel40}  `);
  }

 if (nagel_deburg.nagel_41) {
    debugInfo.push(`📌41 1500 Mindestbewertung bei nur ★Joker-Zügen ges.=🎉 ${nagel41} `);
  }

 if (nagel_deburg.nagel_42) {
    debugInfo.push(`📌42  0.8 ★Joker-Gewichtung⚖️ ges.=🎉 ${nagel42} `);
  }

// 🟠 NAGEL44 (Adaptiver Blockadeparameter) - Ursprünglicher Code:
   // BEGIN * 🟢 ("Nagel44“)  Zusätzlicher adaptiver Blockadeparameter
    // Vorteil: Erhöht den Malus, wenn der Gegner nur wenige Karten im Stock hat.
    // Dies zwingt den Gegner in kritischen Phasen zu weniger optimalen Zügen.

const blockedStock = Math.max(0, 16 - Game.players.human.stock.length);
const Nagel44 = 500 * Math.sqrt(blockedStock); // ✅ Nicht-lineare Blockadeintensität

 if (nagel_deburg.nagel_44) {
    debugInfo.push(`📌44 Erhöht den Malus⬆️500* flex wenn der Gegner wenig Karten♠️hat  `);
    debugInfo.push(`📌44  Malus44 =🎉 ${Nagel44} 🎉 `);
  }

// Erklärung:
// - Nicht-linearer Anstieg (sqrt(16 - Stock)) → Stärkerer Malus bei Stock < 10
// - Maximalwert: Stock=0 → 500×4=2000 (vorher 300×15=4500)
// * Erklärung: Malus erst ab Gegnerstock ≤8 (statt ≤10) + 
//    Maximalstrafe sinkt von 1000→2100 */ was folgt ist die alte Einstellung 
    // END * 🟢 ("Nagel44“)

    const candidates = []; // Liste der möglichen Züge
    const stockSize = Game.players[player].stock.length; // Größe des KI-Stocks
    const stockTop = Game.players[player].stock.slice(-1)[0]?.value; // Oberste Stockkarte (optional chaining)

    // Handkarten durchgehen und Kandidaten erzeugen
    Game.players[player].hand.forEach((card, i) => {
        Game.buildPiles.forEach((pile, pileIndex) => {
            if (isValidBuildMove(card, pileIndex)) {
                let score = 600; // * 🟢 ("Nagel5") Base-Build-Bonus
if (nagel_deburg.nagel_5) {
    debugInfo.push(`📌5  Grundbonus gesetzt⬆️Grundbonus =🎉 ${score} 🎉 `);
  }
                // - Grundbonus für Baustapel-Züge (600) bleibt stabil,
                //   da er eine solide Basis bietet. 
                const gapSize = calculateGapSize(pile, card) || 0; // Schutz vor NaN                
                const futureRisk = calculateFutureRisk(card, pileIndex) || 0;
                let riskScore = getOpponentBlockingPotential(card, pileIndex);
            //  let riskScore = 0;


// dddd Joker_auf_Ablage = false;   
// hier ist die Ünergabe von riskScore aus der Funktion getOpponentBlockingPotential

if (nagel_deburg.nagel_50) {
    debugInfo.push(`📌50 RiskScore-ges.🔥: ${riskScore} von Karte ${card.value} 🟠🟢`);
    debugInfo.push(`📌50 Score-ges.🔥: ${score} von Karte ${card.value} 🟠🟢`);
    debugInfo.push(`📌50 🟢🟠Joker gelegt.🔥: ${Joker_auf_Ablage} 🟠🟢`);
        }



// ddddd. hier kann noch ein score oder ein riskScore gesetzt werden 
// ob das Sinnvoll ist ????
// 
// --------------------------------------------------------------------------
// Überprüfung auf Joker (★)  
let Jokerkarte = card.value;
if (card.value === '★') { // Korrekte Bedingung ohne Platzhalter
    debugInfo.push(`📌50a ★★Joker★★ Es wurde eine Karte ${Jokerkarte} erkannt.`);
    debugInfo.push(`📌50a ⬆️ *13 für den Joker'★' Bedingungen setzen.`);
riskScore += 13 * 50; // Punkte für Joker hinzufügen
    debugInfo.push(`📌50 RiskScore-neu.🔥: ${riskScore} `);
    debugInfo.push(`📌50a Karte geprüft: Wert = ${card.value}`);
    
} else {
    debugInfo.push(`📌50a Kein Joker erkannt. Normale Punkteberechnung.`);
}
// --------------------------------------------------------------------------


                score += gapSize * 110;  // * 🟢 ("Nagel12") Gap-Closing-Bonus (80 pro Lücke)

  if (nagel_deburg.nagel_12) {
    debugInfo.push(`📌12 Skore ⬆️+=GapSize *110  ⬆️Bonus pro 🗑️Lücke `);
    debugInfo.push(`📌12 🎉 Score-ges.=🎉 ${score} GapSize =🎉 ${gapSize} 🎉 futureRisk =🎉 ${futureRisk} 🎉 riskScore =🎉 ${riskScore} 🎉 `);
//    debugInfo.push(`📌12 🎉 Score-ges.=🎉 ${score} `);
//    debugInfo.push(`📌12 GapSize =🎉 ${gapSize} 🎉 `);
//    debugInfo.push(`📌12 futureRisk =🎉 ${futureRisk} 🎉 `);
//    debugInfo.push(`📌12  riskScore =🎉 ${riskScore} 🎉 `);
  }

                score -= futureRisk;   // Malus für zukünftiges Risiko
                score -= riskScore;    // Gegnerhilfe-Malus

if (nagel_deburg.nagel_12) {
    debugInfo.push(`📌12a 🎉 neuer Score-ges.=🎉 ${score} `);
}

                if (card.type === 'joker') {
                    // Zusätzliche Joker-Bewertung:
                    const jokerValue = pile.length === 0 ? 1 : pile[pile.length - 1].value + 1;
                    const matchesStock = stockTop && (jokerValue === stockTop || stockTop === undefined);

if (pile.length < 5 && stockSize > 12 && !matchesStock) {
    try {
        if (canRemoveStockCard()) {
            riskScore -= 5000; // Abbau der Stockkarte priorisieren: hoher Bonus, der den Stockabbau attraktiver macht.
// momentan -=2000 war aber -=5000 Ki was sollte hier sein :?
            if (nagel_deburg.nagel_39) {
                debugInfo.push(`📌39 riskScore🔥⚠️  ⬇️-= 5000; Stockabbau Vorrang RiskScore-ges. = ${riskScore} ⚠️🟢`);
            }
            // Joker-Nutzung wird nur gewertet, wenn kein Stockabbau möglich ist.
        } else {
            // * 🟢 ("Nagel6") Dynamische Joker-Schwelle
            const dynamicMalus = 800 * (1 - (Game.players.ai.stock.length / 20));
            score -= dynamicMalus; //  Malus sinkt linear mit Stockabbau (1500 → 0)

            if (nagel_deburg.nagel_6) {
                debugInfo.push(`📌6  score ⬇️-= 800 Malus sinkt linear mit Stockabbau Score-ges =🎉 ${score}  `);
            }
        }
    } catch (error) {
        console.error("Fehler in canRemoveStockCard (nagel39):", error);
        debugInfo.push("⚠️ Fehler in Nagel39-Logik – Stockabbauprüfung übersprungen.");
        // Joker-Malus trotzdem anwenden als Fallback
        const dynamicMalus = 800 * (1 - (Game.players.ai.stock.length / 20));
        score -= dynamicMalus;
        if (nagel_deburg.nagel_6) {
            debugInfo.push(`📌6 (Fallback) score ⬇️-= 800 Malus bei Fehler Score-ges =🎉 ${score}  `);
        }
    }
}

   if (matchesStock && (pile.length >= 5 || stockSize <= 10)) {
        const topHumanStock = Game.players.human.stock[Game.players.human.stock.length-1]?.value || 1;
        score += (15000 + (2000 * (12 - topHumanStock))); // ✅ Gegnerstockwert-Integration ("nagel7")

if (nagel_deburg.nagel_7) {
    debugInfo.push(`📌7   ⬆️+= 15000  ✅ Score-ges. =🎉 ${score} 🎉 `);
  }

// Erklärung:
// - Basisbonus von 15.000 (statt 12.000) für Stockabbau
// - Zusatzbonus von 2000 × (12 - Gegnerstockwert) → Aggressivere Jokernutzung gegen hohe Gegnerstockwerte
                    }
                    const futureValue = calculateJokerFutureValue(card, pileIndex) || 0;
                    if (futureValue > 0) {
                        // * 🟢 ("Nagel8") Long-Term-Joker-Bonus
                        // - Der zukünftige Nutzen des Jokers wird mit einem Multiplikator von 40 bewertet,
                        //   um den Fokus auf sofortigen Stockabbau zu legen.
                        score += futureValue * 80;

if (nagel_deburg.nagel_8) {
    debugInfo.push(`📌8   future =🎉 ${futureValue} * 80⬆️ Score-ges. =🎉 ${score}  `);
  }

                    }
                }

                // Erzeuge einen Kandidaten für einen gültigen Zug aus der Hand
                candidates.push({ sourceType: 'hand', sourceIndex: i, card, buildPileIndex: pileIndex, score });
            }
        });
    });

    // --- NEUE LOGIK: Doppelte Handkarten-Kandidaten entfernen ---
    // Falls dieselbe Handkarte über mehrere Baustapel spielbar ist, behalten wir nur den
    // Kandidaten mit der höchsten Bewertung, um Mehrfachbewertungen zu vermeiden.
    const uniqueHandCandidates = [];
    const seenHandCandidates = {};
    for (const candidate of candidates) {
        if (candidate.sourceType === 'hand') {
            const key = candidate.sourceIndex; // Identifiziert die Handkarte
            if (!seenHandCandidates.hasOwnProperty(key) || seenHandCandidates[key].score < candidate.score) {
                seenHandCandidates[key] = candidate;
            }
        } else {
            uniqueHandCandidates.push(candidate);
        }
    }
    for (const key in seenHandCandidates) {
        uniqueHandCandidates.push(seenHandCandidates[key]);
    }
    // Damit wird sichergestellt, dass pro Handkarte nur ein Zug bewertet wird.
    const dedupedCandidates = uniqueHandCandidates;
    // Stockkarte prüfen: Wenn der oberste Stockzug spielbar ist, hinzufügen.
    const stockCard = Game.players[player].stock.slice(-1)[0];
    if (stockCard) {
        Game.buildPiles.forEach((pile, pileIndex) => {
if (isValidBuildMove(stockCard, pileIndex)) {
    const advancedPiles = Game.buildPiles.filter(p => p.length > 6).length;
    let score = Math.min(5000, 3000 + (2000 * advancedPiles));

if (nagel_deburg.nagel_10) {
    debugInfo.push(`📌10 📌11 Stockabbau beschleunigen Score-ges. =🎉 ${score} 🎉 `);
  }

    // * 🟢 ("Nagel10") Adaptiver Stock-Bonus (+2000 pro fortgeschrittenem Stapel >6)
    dedupedCandidates.push({ sourceType: 'stock', sourceIndex: 0, card: stockCard, buildPileIndex: pileIndex, score });
}
        });
    }

    // Neue Ablagestapel-Logik:

/********************************************* Anfang
 * 🎭 Dieter manuelle Änderung  🎭
 * Da gapSize mit der Funktion nur 0 zurück gibt 
 * und futureRisk auch nur 0 aus der Funktion zurück gibt
 * ändere ich diese Variabel erst Mal manuel
 * die beiden nachfolgender Variablen können dann wenn die
 * Funktion geht wieder gelöscht werden und wie oben ermittelt 
 * werden   !!!
 *********************************************/


    Game.players[player].discards.forEach((pile, discardIndex) => {
        if (pile.length > 0) {
            const card = pile[pile.length - 1];
            Game.buildPiles.forEach((buildPile, buildIndex) => {
                if (isValidBuildMove(card, buildIndex)) {
                    let score = 300; // * 🟢 ("Nagel26") Basispunkte für Ablagestapelzug
 if (nagel_deburg.nagel_26) {
    debugInfo.push(`📌26   ⬆️= 300 Basispunkte für 🗄️Ablagestapelzug  Score-ges.=🎉 ${score}  `);
  }
//                    score += card.value * 50; // * 🟢 ("Nagel27") Bonus: Höhere Karten werden stärker gewichtet.
debugInfo.push(`📌27 ⬆️+= vorher vor nagel27 Score-ges.=🎉 ${score}`);
const Wertgroese = card.value; // Zur Prüfung   

// dddd
// --------------------------------------------------------------------------
// Der JOKER hat ursprünglichen keinen Wert hi setze ich einen
// Wert score += 13 * 50;  (13) diesen Wert sollte man im Auge behalten 
// Bonus: Höhere Karten werden stärker gewichtet.
// ob es Sinn macht ihn hoch oder ehr tief anzu setzen
// oder mit -= zu arbeiten um negativ zu kommen 
//
try {
    // Überprüfen, ob Wertgroese gültig ist
    if (!isNaN(Wertgroese) && isFinite(Wertgroese)) {
        // Normale Punktberechnung
        score += Wertgroese * 50; // Bonus: Höhere Karten stärker gewichtet
        debugInfo.push(`📌27 Formel_und_Wert__score+=card.value*50`);
        debugInfo.push(`📌27 Wert_card.value = ${Wertgroese}`);
        debugInfo.push(`📌27 ⬆️+= * 50; Höhere Karten stärker gewichtet Score-ges.=🎉 ${score}`);
    } else {
        // Wenn Wert ungültig ist oder Joker erkannt wird, Standardwert verwenden
        score += 13 * 50; // Standardwert für Joker
        debugInfo.push(`📌27 Warnung: Joker erkannt oder ungültiger Wert (NaN). Jokerwert 13 * 50 angewandt.`);
        debugInfo.push(`📌27 ⬆️ *13 für den Joker'★'  jetzt Score-ges.=🎉 ${score}`);
    }

    // Überprüfung auf Joker (★)
    if (Wertgroese === '★') {
        debugInfo.push(`📌27★ "Wegen ★ wurde der Joketwert angewandt: score += 13 * 50"`);
        debugInfo.push(`📌27 ⬆️ *13 für den Joker'★'  jetzt Score-ges.=🎉 ${score}`);
    }
    
    // Zusätzliche Debugging-Informationen für nagel_27
    if (nagel_deburg?.nagel_27) { // Sicherheitsprüfung auf nagel_27
//        debugInfo.push(`📌27 Formel_und_Wert__score+=card.value*50`);
//        debugInfo.push(`📌27 Wert_card.value = ${Wertgroese}`);
//        debugInfo.push(`📌27 ⬆️+= * 50; Höhere Karten stärker gewichtet Score-ges.=🎉 ${score}`);
    } else {
//        debugInfo.push("📌27 Fehler: nagel_27 nicht vorhanden.");
    }
} catch (error) {
    // Fehlerbehandlung und Fallback
    score += 13 * 50; // Jokerwert nutzen
    console.error("Ein Fehler ist aufgetreten:", error);
    debugInfo.push(`📌27 Fehler bei der Berechnung: ${error.message}. Standardwert 13 * 50 verwendet.`);
}
// --------------------------------------------------------------------------


                    if (Game.players[player].stock.some(s => s.value === card.value + 1)) {
                        score += 400; // * 🟢 ("Nagel23") Discard-Stock-Synergy-Bonus (reduziert auf 400).
 if (nagel_deburg.nagel_23) {
    debugInfo.push(`📌23 ⬆️+= 400; Discard-Stock-Synergy-Bonus🎉  Score-ges.=🎉 ${score}  `);
  }
                    }
                    dedupedCandidates.push({
                        sourceType: 'discard',
                        sourceIndex: discardIndex,
                        card: card,
                        buildPileIndex: buildIndex,
                        score: score
                    });
                }
            });
        }
    });

    // ----------------------------------------------
    // Dynamische Joker-Bewertung (Neue Nägel ("Nagel40"), ("Nagel41"), ("Nagel42")
    // ----------------------------------------------
    // Berechne den durchschnittlichen Score der deduplizierten Kandidaten.
    const averageScore = dedupedCandidates.reduce((sum, move) => sum + move.score, 0) / (dedupedCandidates.length || 1);
    // Dynamische Schwelle basierend auf dem Durchschnittsscore und ("Nagel40") (thresholdMultiplier).
    const dynamicThreshold = averageScore * nagel40;

    // Passe alle Joker-Kandidaten an: Multipliziere deren Score mit ("Nagel42") (jokerScoreWeight).
    dedupedCandidates.forEach(move => {
        if (move.card.type === 'joker') {
            move.score *= nagel42; // Beispiel: 1000 wird zu 800 bei ("Nagel42") = 0.8.
        }
    });

    // Prüfe, ob es alternative Nicht-Joker-Züge gibt.
    const hasValidNonJokerMove = dedupedCandidates.some(move => move.card.type !== 'joker' && move.score > 0);

    // Filtere Joker-Züge, wenn deren Score unter der dynamischen Schwelle liegt.
    const filteredCandidates = hasValidNonJokerMove
        ? dedupedCandidates.filter(move => {
            if (move.card.type === 'joker' && move.score < dynamicThreshold) {
if (nagel_deburg.nagel_45) {
                debugInfo.push("❌ ★Joker-Zug wird ignoriert – Wertung zu niedrig:", move.score, "Schwelle:", dynamicThreshold);
}
                return false;
            }
            return true;
        })
        : dedupedCandidates;

    // Falls als einziger verbleibender Zug Joker vorliegen, überprüfe die Mindestbewertung.
    if (!hasValidNonJokerMove && filteredCandidates.length > 0) {
        const onlyJoker = filteredCandidates.every(move => move.card.type === 'joker');
        const bestJokerScore = Math.max(...filteredCandidates.map(move => move.score));
        if (onlyJoker && bestJokerScore < nagel41) { // ("Nagel41") als minJokerScoreIfOnlyOption
if (nagel_deburg.nagel_45) {
            debugInfo.push("⏭ KI beendet ihren Zug – Kein sinnvoller ★Joker-Zug gefunden (beste Bewertung:", bestJokerScore, "Schwelle:", dynamicThreshold, ")");
}

// Dieter
Joker_auf_Ablage = true; 
if (nagel_deburg.nagel_51) {
                debugInfo.push(`📌51★Joker gelegt in Ablage🗑️ gelegt `);    
}

            return []; // Zug wird beendet, wenn der beste Joker-Zug zu niedrig bewertet ist.
        }
    }

    /* Adaptive Prioritäten */
    const enemyAnalysis = predictEnemyStock('human');
    const priorities = calculateDynamicPriorities();

    filteredCandidates.forEach(move => {
        // Stock-Angriffsbonus 🟠 NAGEL34
        if (move.card.value === enemyAnalysis.nextExpected) {
               // Aggressiverer Stock-Bonus bei gegner. Stock <10
const nagel34 = Game.players.human.stock.length < 10 ? 3000 : 1500;
move.score += nagel34 * priorities.stockAttack;

 if (nagel_deburg.nagel_34) {
    debugInfo.push(' 📌34 Erhöhung⬆️ von 1200→2000 Basiswert ');
  }
// - Erhöhung von 1200→2000 Basiswert
// - Gegnerstock-Längenmodifikator (1.5 - Stock/30) → 1.3 bei Stock=6, 1.0 bei Stock=15
        }        
        // Serienbruch-Bonus
        if (detectConsecutiveDiscards('human').includes(move.card.value)) {
            move.score += Math.round(800 * priorities.seriesDisrupt); // * 🟢 ("Nagel35")
              const Schieben = move.score;

 if (nagel_deburg.nagel_35) {
    debugInfo.push(`📌35 🔗Serienunterbrechung🔗 Bonus =🎉 ${Schieben} `);
  }

        }
        // Risikobewertung
        move.score = Math.round(move.score * priorities.riskTaking);
    });

    // Rückgabe aller finalen, gefilterten Kandidaten für die weitere Verarbeitung.
    return filteredCandidates.sort((a, b) => b.score - a.score);
}





 
// Neue Funktion: Berechnet den Zukunftswert eines Jokers
// Simuliert, wie viele Stockkarten durch diesen Joker später gespielt werden könnten
// Anpassbar: 
// - Tiefe der Simulation (aktuell 3 Züge voraus, kann auf 2 oder 5 geändert werden)
// - Bonus pro Stockkarte (aktuell 50, kann z. B. auf 30 oder 70 angepasst werden)
//
// Berechnet den zukünftigen Wert eines Joker-Zugs
function calculateJokerFutureValue(card, buildPileIndex) {
    let futureValue = 0;
    const buildPile = Game.buildPiles[buildPileIndex];
    let pileValue = 1;

    if (buildPile.length > 0) {
        const topCard = buildPile[buildPile.length - 1];
        if (topCard) {
            pileValue = topCard.type === 'joker' ?
                buildPile.length :
                parseInt(topCard.value) + 1;
        } else {
            console.error("topCard ist undefiniert");
            pileValue = 1;
        }
    }

    if (isNaN(pileValue)) {
        console.error("Ungültiger pileValue:", pileValue);
        return 0.01; // 0.01 um teilen durch null zu verhindern 2 Dieter
    }

 // NEU: Stock-Relevanz-Check ########################
//    const currentJokerValue = pileValue; // Wert, den der Joker repräsentiert
// Nachher:
const currentJokerValue = card.type === 'joker' 
    ? getJokerValue(buildPile, buildPile.length)
    : pileValue;
if (neededForStock(currentJokerValue)) {
    const progressiveBonus = 30 * (12 - currentJokerValue);
    futureValue += progressiveBonus; // * 🟢 ("Nagel25") Progressiver Ketten-Bonus
     if (nagel_deburg.nagel_25) {
    debugInfo.push(` 🟢("📌25")JOKER FUTURE: ${currentJokerValue} (+${progressiveBonus})`);
  }
}
    // ###########################################

    // Originale Zukunftsberechnung (1:1 gleich)
    for (let i = 1; i <= 5; i++) {
        const futureCardValue = pileValue + i;
        if (futureCardValue <= 12) {
            futureValue++;
        }
    }

    // NEU: Zusätzlicher Bonus für hohe Werte ###########################
    if (pileValue >= 8) {          // * 🟢 ("Nagel21") pileValue
                              // * - Unverändert bei **≥8**
                              // * - Gewichtung für späte Phasen bleibt, 
                              //  da sie die Ablagestrategie gut steuert.          
        futureValue += 2; // * 🟢 ("Nagel21a") futureValue
 if (nagel_deburg.nagel_21a) {
    debugInfo.push(`📌21a langfristige Planung ⬆️+= 2; Gewichtung für späte Phasen Future-ges.=🌟 ${futureValue}  `);
  }
                                      // * - Unverändert bei **+2**
                                      // * - Gewichtung für späte Phasen bleibt, 
                                      // da sie langfristige Planung unterstützt.
    }
    // ########################################################

    return futureValue;
}


//
// Funktion zum Ablegen einer Karte auf einen Ablagestapel
// Verarbeitet das Ablegen für die KI mit strategischer Bewertung
// Überarbeitet: Neue Stockhilfe-Boni, angepasste Strafen und erweiterte Joker-Logik
// Anpassbare Nagel-Parameter:
//
async function playInDiscardPiles(player) {
    // Prüfe, ob Handkarten vorhanden sind (ursprüngliche Logik)
    if (Game.players[player].hand.length === 0) {
        showMessage('KI hat keine Handkarten zum Ablegen.');
        await pauseForSeconds(1);
        return;
    }

    // Prüfe kritische Karten des Gegners (Topkarte Stock + Ablagestapel)
    const opponentCritical = [
        Game.players.human.stock.slice(-1)[0]?.value,
        ...Game.players.human.discards.map(p => p[p.length - 1]?.value)
    ].filter(v => v !== undefined);

    // Stock-Top mit Null-Check
    const stockTop = Game.players[player].stock.length > 0 
        ? Game.players[player].stock[Game.players[player].stock.length - 1].value 
        : null;
    
    const handCards = Game.players[player].hand;
    const discardPiles = Game.players[player].discards;
    let bestDiscardIndex = -1;
    let bestScore = -Infinity;
    let mainMoveSuccess = false; // Flag um festzuhalten, ob die Hauptablage erfolgreich war

    // Letzte Karte der Hand auswählen
    const cardToPlay = handCards[handCards.length - 1];
    const sourceIndex = handCards.length - 1;
    
    // Bestimme, ob die zu spielende Karte ein Joker ist
    const isJoker = String(cardToPlay.value).toUpperCase() === "JOKER";

    // Gefährliche Karten identifizieren
    const isDangerousCard = opponentCritical.includes(cardToPlay.value);

    // Alle Ablagestapel analysieren
    for (let i = 0; i < discardPiles.length; i++) {
        // Entfernt: Bisherige Sperre für Ablage 4 (Index 3) wurde hier entfernt,
        // so dass alle Ablagestapel unabhängig vom Joker-Status genutzt werden können.
        const pile = discardPiles[i];
        const topCard = pile.length > 0 ? pile[pile.length - 1] : null;
        let score = 150; // * 🟢 ("Nagel13") Discard-Base-Score
  if (nagel_deburg.nagel_13) {
    debugInfo.push(`📌13 Skore = 150; Fördert ⬆️🗑️Baustapel-Nutzung Score-ges.=🎉 ${score} `);
  }
                                    // * - Reduziert von **100** auf **50**
                                    // * - Macht Ablagen weniger attraktiv, 
                                    //  da der Fokus auf Stockzügen liegt. 
                                    //   Fördert Baustapel-Nutzung.
        if (isDangerousCard) {
            score -= 3000; // * 🟢 ("Nagel14") Dangerous-Card-Penalty Version: 4.5.1
  if (nagel_deburg.nagel_14) {
    debugInfo.push(`📌14 score ⬇️= 3000  riskante Ablagen reduzieren Score-ges.=🎉 ${score}  `);
  }
                                     // *Reduzieren auf -3000, um die KI war vorher vor Version: 4.5.1
                                    // weniger stark einzuschränken.
                           // * - Höhere Strafe für riskante Ablagen reduziert 
                           // Gegnerhilfe und zwingt die KI zu sichereren Zügen.
if (nagel_deburg.nagel_45) {
            debugInfo.push(`DISCARD BLOCK: ${cardToPlay.value} ist gefährlich (📌14)`);
}
        }

        // Strategie für leere Stapel
        if (!topCard) {
            score += 20; // * 🟢 ("Nagel16") Empty-Pile-Bonus
  if (nagel_deburg.nagel_16) {
    debugInfo.push(`📌16 Skore ⬆️+= 20; Bonus🎉 für leere 🗄️Ablagestapel Score-ges.=🎉 ${score}  `);
  }
                 //  * - Unverändert bei **+20**
                 // * - Bonus für leere Ablagestapel bleibt, 
                 //      da er die Flexibilität leicht fördert.
                 // Beispiel: Erhöhung auf 40 würde neue Stapel bevorzugen
            if (stockTop && cardToPlay.value === stockTop - 1) {
                score += 50; // * 🟢 ("Nagel18") Stock-Help-Bonus
                                      // * - Unverändert bei **+50**
                                      // * - Bonus für Stockvorbereitung bleibt, 
                         // da er die Ablagen sinnvoll mit Stockzügen verknüpft.
                  if (nagel_deburg.nagel_18) {
    debugInfo.push(`STOCKHILFE: ${cardToPlay.value} vor ${stockTop} 🟢("📌18") `);
  }
            }
        } 
        // Strategie für belegte Stapel
        else if (cardToPlay.value < topCard.value) {
            score += 30; // * 🟢 ("Nagel17") Lower-Card-Bonus
  if (nagel_deburg.nagel_17) {
    debugInfo.push(`📌17 score ⬆️+= 30; Bonus🎉 für niedrigere Karten Score-ges.=🎉 ${score}  `);
  }
                         // * - Unverändert bei **+30**
                         // * - Bonus für niedrigere Karten bleibt, 
                         // da er die Ablagestrategie leicht optimiert.
                         // Beispiel: Erhöhung auf 50 würde kleinere Karten stärker fördern
            if (stockTop && cardToPlay.value === stockTop - 1) {
                score += 50; // * 🟢 ("Nagel17a") Zusätzlicher Stockhilfe
  if (nagel_deburg.nagel_17a) {
    debugInfo.push(`📌17a score ⬆️+= 50; Zusätzlicher Stockhilfe Score-ges.=🎉 ${score}  `);
  }
                          // * - Unverändert bei **+50**
                          // * - Zusätzlicher Bonus für Stockunterstützung bleibt, 
                          //      da er die Stockpriorität ergänzt.
            }
        }

        if (topCard && (cardToPlay.value === topCard.value - 1)) {
            score += 120; // * 🟢 ("Nagel15") Sequence-Bonus
                                    // * - Reduziert von **150** auf **100**
                                    // * - Geringerer Bonus für Ablagesequenzen, 
                                    // um Ablagen als Notlösung zu halten.
              if (nagel_deburg.nagel_15) {
    debugInfo.push(`DISCARD SEQ: ${cardToPlay.value}→${topCard.value} (+120 um⬆️+20 ("📌15")   Score-ges.=🎉 ${score}  `);
  }
        }

        if (stockTop && cardToPlay.value === stockTop + 1) {
            score += 300; // * 🟢 ("Nagel22") Stock-Followup-Bonus
                                    // Er fördert Kombinationszüge.
             if (nagel_deburg.nagel_22) {
    debugInfo.push(`📌22  STOCK-FOLLOWUP: ${cardToPlay.value} nach ${stockTop} (⬆️+300 🟢) Score-ges.=🎉 ${score}  `);
  }
        }

        score -= pile.length * 2; // * 🟢 ("Nagel19") Pile-Size-Malus
 if (nagel_deburg.nagel_19) {
    debugInfo.push(`📌19   ⬇️-= * 2; Malus pro 🗄️Ablagekarte macht große Stapel unattraktiv  Score-ges.=🎉 ${score} `);
  }
   // * - Unverändert bei ***3**  - Malus pro Ablagekarte bleibt, 
   // um große Ablagestapel zu vermeiden.
   // Beispiel: Änderung auf *10 würde Karten gleichmäßiger verteilen

        const pileHelpsOpponent = pile.some(c => opponentCritical.includes(c.value));
        if (pileHelpsOpponent) {
// 🟠 NAGEL20 (Gegnerhilfe-Ablagestrafe) - Ursprünglicher Code:
// alter code                        score -= 4000; // * 🟢 ("Nagel20") Opponent-Help-Penalty
                                   // * - geringern von **-7000** auf **-4000**
                                  // * - Höhere Strafe für Gegnerhilfe bei Ablagen 
                                  //  macht sie unattraktiver und schützt vor Fehlern.
// Angepasst auf:
// ░▒▓ NAGEL 20 - KORREKTUR ▓▒░
const criticalStockPenalty = Game.players.human.stock.length <=5 ? 3000 : 0;
score -= 15000 + criticalStockPenalty; // ✅ Zwei-Stufen-Strafensystem
// Erklärung:

if(Game.players.human.stock.length < 5) score -= 15000; // ⛔ Nagel20-Erweiterung 4.5.1

// - Basisstrafe von 15000 (statt 4000)
// - Zusatzstrafe 3000 wenn Gegnerstock ≤5 (kritische Phase)
              if (nagel_deburg.nagel_20) {
    debugInfo.push(`📌20 GEGNERHILFE: Stapel ⬇️🗑️ ${i+1} (-15000 ⛔ Score-ges.=🎉 ${score}  `);
  }
        }

        // Besten Stapel aktualisieren
        if (score > bestScore) {
            bestScore = score;
            bestDiscardIndex = i;
        }
    }

    // Zug ausführen: Nur wenn eine Karte erfolgreich im Ablagestapel abgelegt wird,
    // wird mainMoveSuccess auf true gesetzt.
    if (bestDiscardIndex >= 0 && handleDiscardPileDrop(player, 'hand', sourceIndex, bestDiscardIndex)) {
        mainMoveSuccess = true;
        showMessage(`KI legt ${cardToPlay.value} in Ablage ${bestDiscardIndex + 1}`);

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI legt ${cardToPlay.value} in Ablage ${bestDiscardIndex + 1} 🎲🎲 `);
  }

        await pauseForSeconds(1);
        updateView();
        
        // Tracking mit neuem Parameter
        trackGameObservations('discardStrategy', {
            cardValue: cardToPlay.value,
            wasDangerous: isDangerousCard,
            stockFollowup: (stockTop && cardToPlay.value === stockTop + 1), 
            createdSequence: discardPiles[bestDiscardIndex]?.slice(-1)[0]?.value
        });
        
        if (checkForWinner()) return;
    } else {
        showMessage('Ablage fehlgeschlagen!');
        await pauseForSeconds(1);
    }
    
    if (mainMoveSuccess) {
        const jokerIndex = Game.players[player].hand.findIndex(card => String(card.value).toUpperCase() === "JOKER");
        if (jokerIndex !== -1) {
            if (handleDiscardPileDrop(player, 'hand', jokerIndex, 3)) {
                showMessage(`KI legt zusätzlichen ★Joker in Ablage 4`);

//ddd
//Joker_auf_Ablage = true; 
//if (nagel_deburg.nagel_51) {
//                debugInfo.push(`📌51★Joker gelegt in Ablage🗑️ gelegt `);    
//}

                await pauseForSeconds(1);
                updateView();
                trackGameObservations('jokerAdditional', { cardValue: "JOKER" });
                if (checkForWinner()) return;
            } else {
                showMessage('Ablage des zusätzlichen Jokers fehlgeschlagen!');
                await pauseForSeconds(1);
            }
        }
    }
}


// Funktion zum Entfernen einer zufälligen Karte aus der Hand (unverändert)
function selectAndRemoveCardFromHand(player) {
    if (Game.players[player].hand.length === 0) {
        return null;
    }
    const randomIndex = Math.floor(Math.random() * Game.players[player].hand.length);
    const card = Game.players[player].hand[randomIndex];
    Game.players[player].hand.splice(randomIndex, 1);
    return card;
}



async function aiTurn() {
    // >>>>>>>> ORIGINALCODE ANFANG <<<<<<<<
    // 1. Handkarten zu Beginn des KI-Zugs auffüllen
    drawCardsUntilFive('ai');
    showMessage('KI bereitet Zug vor...');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI bereitet Zug vor... 🎲🎲 `);
  }

    await pauseForSeconds(0.8);

    let moved = false;
    let moveCount = 0;
    let kein_zug_mehr = 0; // Steuervariable, 0 = Züge möglich, 1 = keine Züge mehr

    // >>>>>>>> NEUER CODE <<<<<<<<
    /* Predictive Analysis */
    showMessage('KI berechnet Zug...');
    await pauseForSeconds(0.5);

    const enemyAnalysis = predictEnemyStock('human');
    const priorities = calculateDynamicPriorities();

    /* Visuelles Feedback */
    Game.buildPiles.forEach((pile, i) => {
        const element = document.querySelector(`.build-pile:nth-child(${i + 1})`);
        if (pile.slice(-1)[0]?.value === enemyAnalysis.nextExpected) {
            element.classList.add('ai-prediction-overlay');
            const tag = document.createElement('div');
            tag.className = 'strategy-tag';
            tag.textContent = `⛔ Blockade ${enemyAnalysis.nextExpected} (${Math.round(enemyAnalysis.confidence * 100)}%)`;
            element.appendChild(tag);
        }
    });

    /* Strategische Zugausführung */
    try {
        if (enemyAnalysis.confidence > 0.6) {
            moved = await executeStockAttack(enemyAnalysis.nextExpected);
        }
    } catch (e) {
        console.error('Stock Attack Failed:', e);
    }
    // >>>>>>>> ORIGINALCODE FORTSETZUNG <<<<<<<<

    // 2. Schleife läuft, solange Züge möglich sind
    do {
        showMessage('KI analysiert mögliche Züge...');
        await pauseForSeconds(0.5);

        // Kandidatenbewertung mit neuer Logik, jedes Mal neu
        const candidates = evaluateMoveCandidates('ai');

        // wenn global niedrigerJoker true ist dann die Schleife verlassen
        if (candidates.length === 0) {
            const stockCard = Game.players.ai.stock.slice(-1)[0];
            let stockPlayable = false;
            if (stockCard) {
                for (let j = 0; j < Game.buildPiles.length; j++) {
                    if (isValidBuildMove(stockCard, j)) {
                        stockPlayable = true;
                        showMessage(`KI legt Stockkarte (${stockCard.value}) auf Bau🗑️ ${j + 1}`);

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI legt Stockkarte (${stockCard.value}) auf Bau🗑️ ${j + 1} 🎲🎲 `);
  }

 if (nagel_deburg.nagel_24) {
    debugInfo.push(' 📌24  score: 8000 Stock-min  ');
  }
 if (nagel_deburg.nagel_24) {
    debugInfo.push(`📌24-1  score ⬆️+= 8000 Stockabbau Score-ges.=🎉 ${score}  `);
   }
                        await pauseForSeconds(1.2);
                        if (handleBuildPileDrop('ai', 'stock', 0, j)) {
                            moved = true;
                            moveCount++;
                            // Tracking für Stockzug mit Debug-Info
                            const trackingData = {
                                sourceType: 'stock',
                                cardValue: stockCard.value,
                                cardType: stockCard.type,
                                buildPileIndex: j,
                                score: 8000 //  * 🟢 ("Nagel24") Stock-min
                                // Anpassung 8000 an Nagel 10, da der Mindestwert 
                                // für Stockzüge mit der neuen Logik steigen sollte.
                            };
                            trackGameObservations('kiMove', trackingData);
                            if (moveCount >= 2) {
                                showMessage('KI führt Kombinationszug aus...');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI führt Kombinationszug aus... 🎲🎲 `);
  }
                                await pauseForSeconds(0.8);
                            }
                        }
                        break;
                    }
                }
            }
            if (!stockPlayable) {
                kein_zug_mehr = 1;
                if (stockCard && Game.buildPiles.some(pile => isValidBuildMove(stockCard, Game.buildPiles.indexOf(pile)))) {
                    const missedData = { stockCardValue: stockCard.value };
                    trackGameObservations('missedStock', missedData);
                    // score -= 1000; //  🟢 ("Nagel31") Missed-Stock-Malus (auskommentiert, da "score" hier nicht definiert ist)
                }
            }
            break;
        }

        candidates.sort((a, b) => b.score - a.score);
        const best = candidates[0];

        // --- Einfügepunkt: Hinzufügen der neuen Bedingung ---
// irgendwie wird dieser Teil bis Ende // --- Ende der Einfügemarke ---
// nicht berücksichtigt ???🟢🟢🟢
        // Hier prüfen wir, ob der beste Zug nicht aus dem Stock stammt, aber die KI in
        // der Hand oder im Ablagestapel eine Karte hat, die identisch zur obersten Stockkarte ist
        // (außer es handelt sich um einen Joker). In diesem Fall soll die Stockkarte gespielt werden.
        const stockCard = Game.players.ai.stock.length > 0 ? Game.players.ai.stock[Game.players.ai.stock.length - 1] : null;
        if (best.sourceType !== 'stock' && stockCard && stockCard.type !== 'joker' && stockCard.value === best.card.value) {
if (nagel_deburg.nagel_31) {
            debugInfo.push("📌31 KI priorisiert 🟢🟢🟢Stockkarte, da sie identisch ist mit der gewählten Karte aus " + best.sourceType);
}
            if (handleBuildPileDrop('ai', 'stock', 0, best.buildPileIndex)) {
       if (nagel_deburg.nagel_32) {
    debugInfo.push(`📌32-1  skore ⬆️+= 5000🟢🟢🟢 Stockabbau Score-ges.=🎉 ${score}  `);
  }
                moved = true;
                moveCount++;
                const trackingData = {
                    sourceType: 'stock',
                    cardValue: stockCard.value,
                    cardType: stockCard.type,
                    buildPileIndex: best.buildPileIndex,
                    score: 5000 // * 🟢 ("Nagel32") Beispielhafter Score für Stockzug
                };
                trackGameObservations('kiMove', trackingData);
                showMessage(`KI legt Stockkarte (${stockCard.value}) auf Bau🗑️ ${best.buildPileIndex + 1}`);

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI legt Stockkarte (${stockCard.value}) auf Bau🗑️ ${best.buildPileIndex + 1} 🎲🎲 `);
  }

       if (nagel_deburg.nagel_32) {
    debugInfo.push(`📌32-2  skore ⬆️+= 5000🟢🟢🟢 Stockabbau Score-ges.=🎉 ${score}  `);
  }
                await pauseForSeconds(1.2);
            }
            // Starte den KI-Zug neu, um sicherzustellen, dass die Stockkarte vorrangig gespielt wurde
            aiTurn();
            return;
        }
        // --- Ende der Einfügemarke ---🟢🟢🟢Prüfe bitte warum

        let sourceText = '';
        switch (best.sourceType) {
            case 'hand': 
                sourceText = `Handposition ${best.sourceIndex + 1}`; 
                break;
            case 'stock': 
                sourceText = 'Stock-Stapel'; 
                break;
            case 'discard': 
                sourceText = `Ablagestapel ${best.sourceIndex + 1}`; 
                break;
        }

        showMessage(`KI spielt ${best.card.type === 'joker' ? '★Joker' : best.card.value} ` +
                    `von ${sourceText} auf Bau🗑️ ${best.buildPileIndex + 1} ` +
                    `(Strategie-Score: ${best.score})`);

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI spielt ${best.card.type === 'joker' ? '★Joker' : best.card.value} ` +
                    `von ${sourceText} auf Bau🗑️ ${best.buildPileIndex + 1} ` +
                    `(Strategie-Score: ${best.score}) 🎲🎲 `);
  }

        await pauseForSeconds(1.2);

        if (handleBuildPileDrop('ai', best.sourceType, best.sourceIndex, best.buildPileIndex)) {
            moved = true;
            moveCount++;
            // Tracking für alle Züge mit Debug-Info
            const trackingData = {
                sourceType: best.sourceType,
                cardValue: best.card.value,
                cardType: best.card.type,
                buildPileIndex: best.buildPileIndex,
                score: best.score // Score des gewählten Zugs
            };
            trackGameObservations('kiMove', trackingData);
            if (moveCount >= 2) {
                showMessage('KI führt Kombinationszug aus...');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI führt Kombinationszug aus... 🎲🎲 `);
  }
                await pauseForSeconds(0.8);
            }
        } else {
            kein_zug_mehr = 1;
            break;
        }
    } while (!kein_zug_mehr);

    // 3. Erzwungener Ablagestapel-Zug, wenn keine Baustapel-Züge mehr möglich sind
    if (Game.players.ai.hand.length > 0) {
        showMessage('KI legt eine Karte auf den Ablagestapel...');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI legt eine Karte auf den Ablagestapel.. 🎲🎲 `);
  }
        await pauseForSeconds(1);
        await playInDiscardPiles('ai');
    } else {
        showMessage('KI hat keine Handkarten zum Ablegen!');
        await pauseForSeconds(1);
    }

    // global niedrigerJoker auf false setzen
    // (auskommentiert: // global niedrigerJoker = false;)

    // 4. Hand auffüllen nach Ablegen (Finales Auffüllen vor Spielerwechsel)
    if (Game.players.ai.hand.length < 5) {
        showMessage('KI zieht nach...');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 Hand auffüllen KI zieht nach... 🎲🎲 `);
  }
        await pauseForSeconds(0.5);
        drawCardsUntilFive('ai');
    }

    // 5. Spielerwechsel mit korrekter Reihenfolge (Am Ende nach allen Schritten)
    showMessage('KI beendet ihren Zug...');
    await pauseForSeconds(0.5);
    switchPlayer();

    // >>>>>>>> NEUER CODE (Cleanup) <<<<<<<<
    document.querySelectorAll('.ai-prediction-overlay, .strategy-tag').forEach(el => el.remove());
    updateView();
}





/**
 * Gezielter Angriff auf gegnerische Stock-Karte
 */
async function executeStockAttack(targetValue) {
  try {
    const validPiles = Game.buildPiles
      .map((pile, i) => ({
        index: i,
        current: pile.slice(-1)[0]?.value || 0
      }))
      .filter(pile => targetValue === 1 ? 
        pile.current === 0 : 
        pile.current === targetValue - 1
      );

    if(validPiles.length === 0) return false;

    const bestPile = validPiles.reduce((a, b) => 
      a.current < b.current ? a : b
    );

    const validCards = [
      ...Game.players.ai.hand.map((c, i) => ({card: c, type: 'hand', index: i})),
      {card: Game.players.ai.stock.slice(-1)[0], type: 'stock', index: 0}
    ].filter(({card}) => 
      card && (card.value === targetValue || card.type === 'joker')
    );

    if(validCards.length === 0) return false;

    const bestCard = validCards.reduce((a, b) => 
      (a.card.type === 'joker' ? 1 : 0) - (b.card.type === 'joker' ? 1 : 0) || 
      b.card.value - a.card.value
    );

  await handleBuildPileDrop('ai', bestCard.type, bestCard.index, bestPile.index);

// Kontrolle Anfang ------------------------------------------------------------
// Füge Debug-Informationen hinzu, um den Zustand nach der Funktion aufzunehmen
const result = await handleBuildPileDrop('ai', bestCard.type, bestCard.index, bestPile.index);
debugInfo.push(` ☢️💣Ergebnis mit ⏩ await Aufruf🎲: ${JSON.stringify(result)}`);
// Füge Debug-Informationen hinzu, um den Zustand nach der Funktion aufzunehmen
const result1 = handleBuildPileDrop('ai', bestCard.type, bestCard.index, bestPile.index);
debugInfo.push(`☢️💣Ergebnis ohne ⏪ await Aufruf🎲: ${JSON.stringify(result1)}`);
// Ende Kontrolle kann gelöscht werden ------------------------------

    return true;
  } catch (e) {
    console.error('Stock Attack Error:', e);
    return false;
  }
}


// Modifizierte switchPlayer-Funktion
async function switchPlayer() {
    if (checkForWinner()) return;

    if (currentPlayer === 'human') {
        currentPlayer = 'ai';
        showMessage('KI ist am Zug...');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 KI ist am Zug... 🎲🎲 `);
  }
        await pauseForSeconds(1.2);
        aiTurn();
    } else {
        currentPlayer = 'human';
        showMessage('Dein Zug!');

 if (nagel_deburg.nagel_43) {
    debugInfo.push(`📌43 🎲🎲 Dein Zug! 🎲🎲 `);
  }
        await pauseForSeconds(0.5);
        
        // Hand des menschlichen Spielers auffüllen
        drawCardsUntilFive('human');
        setupTouchEvents();
        
        showMessage('Wähle eine Karte aus...');
        await pauseForSeconds(1.5);
    }
}


// NEUE HILFSFUNKTIONEN
// Berechnet die Lücke zwischen dem aktuellen Wert des Baukartenstapels und dem Wert der Karte
function calculateGapSize(pile, card) {
  // Sicherstellen, dass ein gültiger Kartenwert vorliegt:
  if (!card || !card.value) {
    return 0.01;  // 0.01 um teilen durch null zu verhindern 3 Dieter
  }
  const cardValue = parseInt(card.value, 10);

  // Wenn der Stapel leer ist, nehmen wir an, dass der Bonus
  // den Kartenwert als Lücke widerspiegelt (alternativ: cardValue - 1).
  if (!pile || pile.length === 0) {
    return cardValue;  // oder alternativ: cardValue - 1, je nach gewünschtem Startbonus
  } else {
    // Letzte Karte im Stapel ermitteln:
    const lastCard = pile[pile.length - 1];
    const lastValue = parseInt(lastCard.value, 10);
    
    // Berechne die Lücke als Differenz – NICHT minus 1!
    const gap = cardValue - lastValue;
    
    // Sollte der Wert negativ sein (wenn etwa ein Fehler vorliegt), geben wir 0 zurück:
    return gap > 0 ? gap : 0;
  }
}


function getDiscardSequenceBonus(player, discardIndex, newCard) {
  const pile = Game.players[player].discards[discardIndex];
  if (pile.length === 0) return 0.01;  // 0.01 um teilen durch null zu verhindern 4 Dieter
  const topValue = pile[pile.length-1].value;
 return (newCard.value === topValue - 1) ? 150 : 0;
if (nagel_deburg.nagel_15) {
debugInfo.push(' (📌15 Zusatz) -return (newCard.value === topValue - 1) ? 150 : 0; strategische Muster zu fördern ');
}
// * Erklärung: +50% Bonus für sequenzbildende Ablagen, 
//   um strategische Muster zu fördern *
// zusätzliche * 🟢 ("Nagel15") 
// um Ablagen als Notlösung zu halten.
// return (newCard.value === topValue - 1) ? 15 : 0; // war in Wirklichkeit 15
// return (newCard.value === topValue - 1) ? 150 : 0; // Aktueller Wert: +150
// return (newCard.value === topValue - 1) ? 100 : 0; // NEUER WERT: +100
}


// Erweiterte Gegneranalyse
// Prüft nicht nur Topkarten, sondern alle Karten in Ablagestapeln des Gegners
// Anpassbar:
// - Malus für nächste Zahl (aktuell 500, kann z. B. auf 800 geändert werden)
// - Kritischer Malus bei Stock ≤ 3 (aktuell +1000, kann auf +1500 angepasst werden)
// - Joker-Malus (aktuell 50, kann z. B. auf 40 oder 60 geändert werden)
//
function getOpponentBlockingPotential(card, buildPileIndex) {
    // Sammle alle sichtbaren Karten des Gegners (Topkarte vom Stock + alle Ablagestapelkarten)
    const opponentVisible = [
        ...Game.players.human.stock.slice(-1), // Topkarte vom Stock
        ...Game.players.human.discards.flat()  // Alle Karten aus Ablagestapeln
    ];
    
    let riskScore = 0; // Initialer Risiko-Score

// dddd ursprünglich hier


    const opponentStockSize = Game.players.human.stock.length; // Größe des gegnerischen Stocks

    // Prüfe jede sichtbare Gegnerkarte
    opponentVisible.forEach(oppCard => {
        // Wenn die Gegnerkarte die nächste oder vorherige Zahl ist (z. B. KI legt 6, Gegner hat 7 oder 5)
        if (oppCard.value === card.value + 1) {
    // 🟠 NAGEL1 (Gegnerhilfe-Malus) - Ursprünglicher Code:
// alter code const stockFactor = 1 - (Game.players.ai.stock.length / 20);
//   alter Code  riskScore += 4000 * stockFactor; // * 🟢("Nagel1") Dynamischer Maltus
                                             // * - Erhöht von **+250** auf **+2000**
                                             // * - Macht riskante Stockzüge teurer, wenn 
                                             //      sie dem Gegner direkt helfen (z. B. KI 
                                             //       legt 6, Gegner hat 7).
                                             // *   Die hohe Strafe zwingt die KI, solche 
                                             //      Züge zu vermeiden, 
                                             //       wenn der Stockbonus nicht überwiegt.
// Angepasst auf:
// ░▒▓ NAGEL 1 - KORREKTUR ▓▒░
const stockFactor = 1 - (Game.players.ai.stock.length / 20);
const humanStockImpact = 1 + (15 - Game.players.human.stock.length) / 15;
riskScore += 8000 * stockFactor * humanStockImpact; // ✅ Multiplikative Verknüpfung
if (nagel_deburg.nagel_1) {
    debugInfo.push(`📌1 riskScore⚠️  ⬆️+= 8000 RiskScore-ges. = ${riskScore} 🟢`);
}
// Erklärung: 
// - Erhöhung von 4000→6000 für stärkere Blockadeprävention
// - Multiplikation mit (15 - Gegnerstock) → Malus steigt bei Gegner in kritischer Phase (Stock ≤8)
// alter Wert 15-  neuer 20-

            if (Game.players.ai.stock.length <= 5) {
    // ursprünglich <= 5
    riskScore -= 500 * (6 - Game.players.ai.stock.length);
}
if (nagel_deburg.nagel_2) {
    debugInfo.push(`📌2  riskScore⚠️  ⬇️-= 500 RiskScore-ges. = ${riskScore} 🟢 `);
}
                          // * 🟢 ("Nagel2") Critical-Stock-Malus
                           //  * - Verstärkt die Strafe, wenn der Gegnerstock 
                           //       klein ist (≤ 3), um die KI im Endspiel defensiver 
                           //        zu machen.
                           //  *   Das schützt vor unnötiger Hilfe, wenn der Gegner 
                           //       fast gewonnen hat.
        }
        // Zusätzliche Prüfung für vorherige Zahl (z. B. KI legt 6, Gegner hat 5)
        if (oppCard.value === card.value - 1) {
            riskScore += 600; // 🟢 ("Nagel28") Sequenzkontrolle
 if (nagel_deburg.nagel_28) {
    debugInfo.push(`📌28 riskScore⚠️  ⬆️+= 600; Sequenzkontrolle RiskScore-ges. = ${riskScore} 🟢`);
  }
                                          // Strafe für um Gegnersequenzen zu bremsen.
            if (opponentStockSize <= 3) riskScore += 3000; // Kritischer Malus 🟢 ("Nagel29") Risky-Stock-Malus
 if (nagel_deburg.nagel_29) {
    debugInfo.push(`📌29 riskScore⚠️  ⬆️+= 3000; Kritischer Malus RiskScore-ges. = ${riskScore} 🟢`);
  }
                                              // Verstärkte Strafe bei kritischem Stock 
                                               // bleibt, um Endspielrisiken zu minimieren. vorh.10
        }
        // Prüfung für gegnerische Joker, die gefährlich sein könnten
         if (oppCard.type === 'joker' && card.value >= 5) {
            riskScore += 60; // * 🟢 ("Nagel4") ★Joker-Risk-Malus
if (nagel_deburg.nagel_4) {
    debugInfo.push(`📌4  riskScore⚠️ ⬆️+= 60; ★Joker-Risk-Malus RiskScore-ges. = ${riskScore} 🟢`);
  }
                                   // * - Erhöht von **+50** auf **+60**
                                   // * - Leichte Anpassung, um gegnerische Joker 
                                   //      etwas riskanter zu bewerten.
                                   // *   Fördert die KI, Züge zu vermeiden, die 
                                   //      gegnerische Joker nutzbar machen.
            if (opponentStockSize <= 3) riskScore += 80; // ("Nagel30") Vorher +100 bei ≤ 5
 if (nagel_deburg.nagel_30) {
    debugInfo.push(`📌30 riskScore⚠️  ⬆️+= 80; Risky-Stock-★Joker-Schwelle RiskScore-ges. = ${riskScore} 🟢`);
  }
                 // * 🟢 NAGEL30a: Risky-Stock-Joker-Schwelle
                 // Unverändert bei **≤3**
                 // Schwelle bei ≤ 3 bleibt, da sie das Endspiel gut abdeckt.
        }
    });

    // NEU: Sequenzprüfung für indirekte Hilfe (z. B. Gegner hat 6 und 8, KI legt 7)
    opponentVisible.forEach((cardA, i) => {
        opponentVisible.slice(i + 1).forEach(cardB => {
            // Prüfe, ob zwei Karten eine Lücke von 2 haben (z. B. 6 und 8)
            if (Math.abs(cardA.value - cardB.value) === 2) {
                // Wenn die aktuelle Karte die Lücke füllt (z. B. 7 zwischen 6 und 8)
                if (card.value === (cardA.value + cardB.value) / 2) {
                    riskScore += 800; // * 🟢 ("Nagel3") Sequence-Gap-Malus
if (nagel_deburg.nagel_3) {
    debugInfo.push(`📌3  riskScore⚠️  ⬆️+= 800  RiskScore-ges. = ${riskScore} 🟢`);
}
                       // * - Erhöht von **+700** auf **+800**
                        // * - Bestraft das Schließen von Gegnersequenzen 
                        // (z. B. Gegner hat 6 und 8, KI legt 7) stärker.
                        //  *   Die Erhöhung macht die KI vorsichtiger bei 
                        //       indirekter Hilfe.
                }
            }
        });
    });

// --------------------------------------------------------------------------
// hier am Ende der Funktion wird riskScore gesamt weiter geschickt
// hier kann ich wenn der Joker in der Ablage gelegt wurde noch
// den riskScore anpassen ursprüngliche war das am Anfang der
// Funktion eingebaut diese beeinflussen vom riskScore dddd
// Hiermit will ich versuchen in atum zuerst den Stock abzubauen 
// beim neuen Aufruf fängt riskScore wieder als Jungfrau an
// hier am Schluss wird Joker_auf_Ablage = false; gesetzt.
// Also nur für ein Durchgang ist die Übergabe ein hoher riskScore
//
  if (Joker_auf_Ablage === true) {
        delayWithCallback(10, () => { // 100 Millisekunden Verzögerung
            try {
                // Risikoanpassung für Stockabbau priorisieren
                riskScore -= 15000;

                if (nagel_deburg?.nagel_49) { // Sicherheitsprüfung auf Existenz
                    debugInfo.push('📌49 🔥⚠️In Ablage-Karte liegt ein Joker🔥🔥🔥');
                    debugInfo.push(`📌49 riskScore🔥⚠️ ⬇️-= 15000; Stockabbau Vorrang RiskScore-ges. = ${riskScore} ⚠️🟢`);
                } else {
                    debugInfo.push("📌49 Fehler! nagel_deburg.nagel_49 nicht gefunden.");
                }

                // Zustand zurücksetzen
                Joker_auf_Ablage = false;
            } catch (error) {
                // Fehlerprotokollierung
                console.error("Ein Fehler ist bei getOpponentBlockingPotential aufgetreten:", error);
                debugInfo.push(`📌49 Fehler in getOpponentBlockingPotential: ${error.message}`);
                // Stabilität sicherstellen
                Joker_auf_Ablage = false; // Zustand zurücksetzen
            }
        });
    }
// --------------------------------------------------------------------------

    // Debug-Info zur Nachverfolgung des Risikos * 🟢 ("Nagel50")
if (nagel_deburg.nagel_50) {
    debugInfo.push(`📌50 Rückspung aus Funktion RiskScore-ges.🔥: ${riskScore} von Karte ${card.value} 🟠🟢`);
        }

    return riskScore; // Rückgabe des Gesamtrisiko-Scores
}





function calculateFutureRisk(card, pileIndex) {
  // Sicherstellen, dass die Karte einen gültigen Wert besitzt
  if (!card || !card.value) {
    return 0.01; // 0.01 um teilen durch null zu verhindern 5 Dieter
  }
  const cardValue = parseInt(card.value, 10);
  
  // Basisfaktor – dieser Wert kann angepasst werden, um das Risiko zu skalieren:
  const basisFaktor = 5;
  // Falls kein pileIndex übergeben wird, setzen wir ihn auf 0
  const indexFaktor = (pileIndex !== undefined) ? pileIndex : 0;
  
  // Berechne das Risiko:
  // Je niedriger der Kartenwert, desto höher das Risiko, da man damit den Stapel "schlechter" abschließt.
  // Hier als Beispiel: risk = (maximaler Kartenwert (12) - aktueller Kartenwert) * (basisFaktor + pileIndex)
  const risk = (12 - cardValue) * (basisFaktor + indexFaktor);
  
  return risk;
}





// Hilfsfunktion: Sortiert die Handkarten strategisch (niedrigere Zahlen vor Jokern)
// sodass die KI optimal agieren kann.
function orderCardsForMove(player) {
  let handCopy = Game.players[player].hand.slice();
  handCopy.sort((a, b) => {
    if (a.type === 'number' && b.type === 'number') {
      return a.value - b.value;
    } else if (a.type === 'number') {
      return -1;
    } else if (b.type === 'number') {
      return 1;
    } else {
      return 0.01; // Beide Joker: gleich behandeln 0.01 um teilen durch null zu verhindern 6 Dieter
    }
  });
  return handCopy;
}


// Funktion zur Aktualisierung der Bauplätze
function updateBuildPiles() {
  const buildPiles = document.querySelectorAll('.build-pile');
  buildPiles.forEach((pile, index) => {
    const cards = Game.buildPiles[index];
    if (cards.length > 0) {
      const topCard = cards[cards.length - 1];
      if (topCard.type === 'joker') {
        const jokerValue = getJokerValue(cards, cards.length - 1);
        pile.innerHTML = `
          <div class="field card" 
               data-type="joker" 
               data-value="joker">
            <!-- Joker-Zahl bleibt unverändert -->
                         data-pile-index="${index}">
                        <div class="card-corner top-left">★</div>
                        <div class="joker-number">${jokerValue}</div>  <!-- Verschoben nach oben -->
                        <div class="card-corner top-right">★</div>
                        <div class="card-middle">★</div>
                        <div class="card-corner bottom-left">★</div>
                        <div class="card-corner bottom-right">★</div>
                    </div>
                `;
            } else {
                pile.innerHTML = `
                    <div class="field card" 
                         data-type="${topCard.type}" 
                         data-value="${topCard.value}"
                         data-pile-index="${index}">
                        <div class="card-corner top-left">${topCard.value}</div>
                        <div class="card-corner top-right">${topCard.value}</div>
                        <div class="card-middle">${topCard.value}</div>
                        <div class="card-corner bottom-left">${topCard.value}</div>
                        <div class="card-corner bottom-right">${topCard.value}</div>
                    </div>
                `;
            }
        } else {
            pile.innerHTML = `<div class="field" data-pile-index="${index}">Leer</div>`;
        }
    });
}


// Funktion zur Aktualisierung der Ablagestapel
function updateDiscardPiles() {
    // Update Spieler-Ablagestapel
    const playerDiscardPiles = document.querySelectorAll('.human-area [data-label*="Ablage"]');
    playerDiscardPiles.forEach((pile, index) => {
        const cards = Game.players.human.discards[index];
        if (cards && cards.length > 0) {
            const topCard = cards[cards.length - 1];
            pile.innerHTML = `
                <div class="field card" data-type="${topCard.type}" data-value="${topCard.value}">
                    <div class="card-corner top-left">${topCard.value}</div>
                    <div class="card-corner top-right">${topCard.value}</div>
                    <div class="card-middle">${topCard.value}</div>
                    <div class="card-corner bottom-left">${topCard.value}</div>
                    <div class="card-corner bottom-right">${topCard.value}</div>
                </div>
            `;
        } else {
            pile.innerHTML = '<div class="field">Leer</div>';
        }
    });

    // Update KI-Ablagestapel
    const aiDiscardPiles = document.querySelectorAll('.opponent-area [data-label*="Ablage"]');
    aiDiscardPiles.forEach((pile, index) => {
        const cards = Game.players.ai.discards[index];
        if (cards && cards.length > 0) {
            const topCard = cards[cards.length - 1];
            pile.innerHTML = `
                <div class="field card" data-type="${topCard.type}" data-value="${topCard.value}">
                    <div class="card-corner top-left">${topCard.value}</div>
                    <div class="card-corner top-right">${topCard.value}</div>
                    <div class="card-middle">${topCard.value}</div>
                    <div class="card-corner bottom-left">${topCard.value}</div>
                    <div class="card-corner bottom-right">${topCard.value}</div>
                </div>
            `;
        } else {
            pile.innerHTML = '<div class="field">Leer</div>';
        }
    });
}


// Funktion zur Aktualisierung der Hand eines Spielers
function updateHand(player, container) {
    container.innerHTML = Game.players[player].hand.map((card) => `
        <div class="field card ${card.faceUp ? '' : 'backface'}" 
             data-type="${card.type}" 
             data-value="${card.value}">
            ${card.faceUp && player === 'human' ? `
                <div class="card-corner top-left">${card.value}</div>
                <div class="card-corner top-right">${card.value}</div>
                <div class="card-middle">${card.value}</div> <!-- Große Zahl in der Mitte -->
                <div class="card-corner bottom-left">${card.value}</div>
                <div class="card-corner bottom-right">${card.value}</div>
            ` : ''}
        </div>
    `).join('');
}


// Funktion zur Aktualisierung des Stockstapels
function updateStock(player, container) {
  const stock = Game.players[player].stock;
  if (stock.length > 0) {
    const topCard = stock[stock.length - 1];
    container.innerHTML = `
      <div class="field card" 
           data-type="${topCard.type}" 
           data-value="${topCard.value}">
        <!-- Bestehende Elemente -->
        <div class="card-corner top-left">${topCard.value}</div>
        <div class="card-corner top-right">${topCard.value}</div>
        <div class="card-middle">${topCard.value}</div>
        <div class="card-corner bottom-left">${topCard.value}</div>
        <div class="card-corner bottom-right">${topCard.value}</div>
        
        <!-- Neue Stock-Zahlenanzeige -->
        <div class="stock-count">${stock.length}</div>
      </div>
    `;
  } else {
    container.innerHTML = '<div class="field">🗃️ Leer</div>';
  }
}


/* Funktion, die das Element "status-label" verschiebbar macht */
function enableDraggableStatusLabel() {
    // Hole die Meldungsbox anhand ihrer ID
    const label = document.getElementById('status-label');

    // Setze größere Schrift, blaue Schriftfarbe und einen weißen Rand (simuliert über text-shadow)
    label.style.fontSize = '1.5rem';
    label.style.color = 'black';
    label.style.textShadow = '-1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff';
    
    // Variablen zur Speicherung des Drag-Status und der Positionsdaten
    let isDragging = false;
    let startY = 0;       // Y-Position beim Beginn des Drags
    let startTop = 0;     // Aktueller "top"-Wert der Meldungsbox vor dem Drag

    // Entfernt sofort CSS-Transitions, damit die Box während des Drags flüssig folgt
    function disableTransition() {
        label.style.transition = 'none';
    }

    // Aktiviert CSS-Transitions für einen sanften Übergang (Ease-out) und den Skalierungseffekt
    function enableTransition() {
        label.style.transition = 'top 0.3s ease-out, transform 0.3s ease-out';
    }
    
    // Simuliert einen kurzen Bounce-Effekt beim Loslassen der Box
    function bounceEffect() {
        label.style.transform = 'scale(1.15)'; // Leichte Vergrößerung
        setTimeout(() => {
            label.style.transform = 'scale(1)'; // Rückkehr zur Originalgröße nach 300ms
        }, 300);
    }
    
    // Desktop: Bei mousedown starten wir den Drag-Vorgang
    label.addEventListener('mousedown', function(e) {
        isDragging = true;                   // Start des Drag-Vorgangs
        startY = e.clientY;                  // Speichert den aktuellen Y-Wert der Maus
        startTop = parseInt(window.getComputedStyle(label).top) || 0;  // Ermittelt den aktuellen "top"-Wert der Box
        disableTransition();                 // Deaktiviert CSS-Transitions für unmittelbare Positionsänderungen
        e.preventDefault();                  // Verhindert unerwünschte Aktionen (z. B. Textauswahl)
    });
    
    // Desktop: Aktualisiert die Position der Box während des Drag-Vorgangs
    document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        const delta = e.clientY - startY;    // Berechnet die Verschiebung in Y-Richtung
        label.style.top = (startTop + delta) + 'px'; // Aktualisiert den "top"-Wert entsprechend
    });
    
    // Desktop: Beendet den Drag-Vorgang, wenn die Maustaste losgelassen wird
    document.addEventListener('mouseup', function() {
        if (isDragging) {
            enableTransition();  // Reaktiviert CSS-Transitions für einen sanften Endeffekt
            bounceEffect();      // Löst den Bounce-Effekt aus, um das Loslassen zu visualisieren
        }
        isDragging = false;
    });
    
    // Mobile: Bei touchstart starten wir den Drag-Vorgang
    label.addEventListener('touchstart', function(e) {
        isDragging = true;
        startY = e.touches[0].clientY;       // Speichert den Y-Wert des ersten Touch-Punktes
        startTop = parseInt(window.getComputedStyle(label).top) || 0;
        disableTransition();
        e.preventDefault();
    });
    
    // Mobile: Aktualisiert die Position während des Drag-Vorgangs
    document.addEventListener('touchmove', function(e) {
        if (!isDragging) return;
        const delta = e.touches[0].clientY - startY;
        label.style.top = (startTop + delta) + 'px';
    });
    
    // Mobile: Beendet den Drag-Vorgang, wenn der Touch endet
    document.addEventListener('touchend', function() {
        if (isDragging) {
            enableTransition();
            bounceEffect();
        }
        isDragging = false;
    });
}


// Funktion zur Aktualisierung des Nachziehstapels
function updateDrawPile(container) {
    if (Game.drawPile.length > 0) {
        container.innerHTML = `
            <div class="field card backface">
                <div class="card-corner top-left">SKIP-BO</div>
                <div class="card-corner top-right">SKIP-BO</div>
                <div class="card-middle">SKIP-BO</div>
                <div class="card-corner bottom-left">SKIP-BO</div>
                <div class="card-corner bottom-right">SKIP-BO</div>
            </div>
        `;
    } else {
        container.innerHTML = '<div class="field">🃏 Leer</div>';
    }
}


// Funktion zum Anhalten des Codes für eine bestimmte Anzahl von Sekunden
function pauseForSeconds(multiplier = 1) {
    return new Promise((resolve) => {
        setTimeout(resolve, spielGeschwindigkeit * multiplier * 1000);
    });
 }

// Altanativen Funktion hier können verschiedene Zeiten jeweils
// genutzt werden in den Funktionen mit (4) dann diese
// auskomentieten und () einzeln füllen mit zb. (6)
// function pauseForSeconds(seconds) {
//    return new Promise(resolve => {
  //      setTimeout(resolve, seconds * 1000); // Direkte Sekundenangabe
 //   });
// }


// Funktion zum Anzeigen von Nachrichten im Statuslabel
function showMessage(message) {
    const statusLabel = document.getElementById('status-label');
    statusLabel.textContent = message;
    statusLabel.style.minHeight = '40px'; // oder eine andere geeignete Höhe
}

// Initialisierung des Spiels
document.addEventListener('DOMContentLoaded', () => {
    initGame();
    setupTouchEvents();
});


// Prüft, ob eine Karte legal auf einen Baustapel gelegt werden kann
function isValidBuildMove(card, buildPileIndex) {
    const buildPile = Game.buildPiles[buildPileIndex];
    
    // Wenn Stapel leer, nur 1 oder Joker erlaubt
    if (buildPile.length === 0) {
        return card.type === 'joker' || parseInt(card.value) === 1;
    }
    
    const topCard = buildPile[buildPile.length - 1];
    const topValue = topCard.type === 'joker' ? 
        buildPile.length : parseInt(topCard.value);
    const cardValue = parseInt(card.value);
    
    // Joker ist immer erlaubt, ansonsten muss es die nächste Zahl sein
    return card.type === 'joker' || cardValue === (topValue + 1);
}


// Prüft ob ein Baustapel voll ist (12 oder Joker als 12)
function isBuildPileComplete(buildPileIndex) {
    const buildPile = Game.buildPiles[buildPileIndex];
    if (buildPile.length === 0) return false;
    
    const topCard = buildPile[buildPile.length - 1];
    return topCard.value === 12 || (topCard.type === 'joker' && buildPile.length === 12);
}


// Leert einen vollen Baustapel und mischt die Karten in den Nachziehstapel
function clearBuildPile(buildPileIndex) {
    if (isBuildPileComplete(buildPileIndex)) {
        const clearedCards = Game.buildPiles[buildPileIndex];
        Game.buildPiles[buildPileIndex] = [];
        
        // Karten in den Nachziehstapel mischen
        Game.drawPile = Game.drawPile.concat(clearedCards);
        shuffleDrawPile();
    }
}


// Mischt den Nachziehstapel
function shuffleDrawPile() {
    for (let i = Game.drawPile.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [Game.drawPile[i], Game.drawPile[j]] = [Game.drawPile[j], Game.drawPile[i]];
    }
}


// Funktion zur Anzeigen des Hinweisfensters
let pressTimer;

function showInfoWindow(event, discardPileIndex, player) {
    const infoWindow = document.getElementById('info-window');
    const infoTable = document.getElementById('info-table');
    infoTable.innerHTML = ''; // Clear previous content

    const cards = Game.players[player].discards[discardPileIndex];
    if (cards && cards.length > 0) {
        cards.reverse().forEach(card => {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.textContent = card.type === 'joker' ? '*' : card.value;
            row.appendChild(cell);
            infoTable.appendChild(row);
        });

        const rect = event.target.getBoundingClientRect();
        infoWindow.style.left = `${rect.left + window.scrollX}px`;
        infoWindow.style.top = `${rect.top + window.scrollY - infoWindow.offsetHeight - 10}px`;
        infoWindow.style.display = 'block';

        setTimeout(() => {
            infoWindow.style.display = 'none';
        }, 5000);
    }
}


// Funktion handleLongPress
function handleLongPress(event, discardPileIndex, player) {
    pressTimer = setTimeout(() => {
        showInfoWindow(event, discardPileIndex, player);
    }, 1000); // 1 Sekunde lang gedrückt halten
}


// Funktion handleRelease
function handleRelease() {
    clearTimeout(pressTimer);
}


// 
// Funktion zum Beenden des Spiels
// Zeigt das Endergebnis an und deaktiviert Interaktionen
// Neu: Ruft die Analyse direkt im Gewinnfenster auf
// Anpassbar:
// - Stil des Gewinnfensters (z. B. Größe, Farben) kann geändert werden
// - Beobachtungsdaten können erweitert werden (z. B. Spielzeit hinzufügen)
//
function endGame(winner, loser, points) {
    // Speichere Beobachtungen und hole Analyse
    const analysis = trackGameObservations('gameEnd', {
        winner: winner,
        loserStockSize: Game.players[loser === 'KI' ? 'ai' : 'human'].stock.length
    });
    
    // Zeige Gewinnfenster mit Analyse
    showEndGameMessage(winner, loser, points, analysis);
    document.getElementById('game-board').style.pointerEvents = 'none';
}


// Funktion zur Überprüfung, ob ein Spieler gewonnen hat (KORRIGIERTE VERSION)
function checkForWinner() {
    if (Game.players.human.stock.length === 0) {
        // Human hat gewonnen - KI-Punkte basieren auf KI-Stockkarten
        const aiPoints = Game.players.ai.stock.length * 5; // Änderung: .stock statt .hand
        endGame(playerName, 'KI', aiPoints);
        return true;
    } else if (Game.players.ai.stock.length === 0) {
        // KI hat gewonnen - Human-Punkte basieren auf Human-Stockkarten
        const humanPoints = Game.players.human.stock.length * 5; // Änderung: .stock statt .hand
        endGame('KI', playerName, humanPoints);
        return true;
    }
    return false;
}



// 
// Funktion zur Anzeige der Endspielnachricht als Overlay
// Integriert jetzt die Analyse direkt im Gewinnfenster
// und speichert die Daten automatisch in Ergebnis.txt
// Anpassbar:
// - Stil des Overlays (z. B. Größe, Farben) kann geändert werden
// - Textarea-Größe (height) oder Button-Styling kann angepasst werden
//
function showEndGameMessage(winner, loser, points, analysis) {
    // Overlay-Container erstellen
    const overlay = document.createElement('div');
    overlay.id = 'end-game-overlay';
    
    // Stil für das Overlay (90% der Bildschirmhöhe und beginnt 5% unterhalb des oberen Randes)
    overlay.style.position = 'fixed';
    overlay.style.top = '5vh'; // Startet 5% unterhalb des oberen Bildschirmrands
    overlay.style.left = '0';
    overlay.style.width = '100vw';
    overlay.style.height = '90vh'; // Nimmt 90% der Bildschirmhöhe ein
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    overlay.style.display = 'flex';
    overlay.style.flexDirection = 'column';
    overlay.style.justifyContent = 'flex-start'; // Inhalte beginnen oben
    overlay.style.alignItems = 'center';
    overlay.style.color = 'white';
    overlay.style.fontSize = '2em';
    overlay.style.fontWeight = 'bold';
    overlay.style.zIndex = '1000';
    overlay.style.textAlign = 'center';
    overlay.style.overflowY = 'auto'; // Scroll-Unterstützung für lange Inhalte
    overlay.style.paddingTop = '20px'; // Zusätzlicher Abstand für die Inhalte
    overlay.style.paddingBottom = 'env(safe-area-inset-bottom)'; // Dynamischer Abstand unten

    // Inhalt des Overlays mit Analyse-Daten
    overlay.innerHTML = `
        <div style="background: white; color: black; padding: 30px; 
                    border-radius: 10px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.5); 
                    position: relative; width: 80%; max-width: 600px;">
            <h1 style="font-size: 2em;">Spiel beendet!</h1>
            <p><strong>Gewinner:</strong> ${winner} 🎉</p>
            <p><strong>Verlierer:</strong> ${loser} mit ${points} Punkten</p>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="restart-button" 
                        style="font-size: 0.6em; padding: 10px 20px; height: 40px; 
                               background: #4CAF50; color: white; border: none; 
                               border-radius: 5px; cursor: pointer; line-height: 20px;">
                    Neues Spiel
                </button>
                
                <button id="save-button" 
                        style="font-size: 0.6em; padding: 10px 20px; height: 40px; 
                               background: #2196F3; color: white; border: none; 
                               border-radius: 5px; cursor: pointer; line-height: 20px;">
                    Speichern
                </button>
            </div>
            
            <div id="analysis-section" 
                 style="margin-top: 20px; text-align: left; font-size: 0.8em;">
                <h2 style="font-size: 1.2em;">Version 4.5.2 -Auswertung-</h2>
                <textarea style="width: 100%; height: 250px; font-size: 14px; resize: none;"
                          readonly>${analysis}</textarea>
                <p style="font-size: 0.8em;">Kopiere den Text und sende ihn an den Entwickler!</p>
                
                <button id="close-analysis" 
                        style="font-size: 0.8em; padding: 10px 20px; height: 40px; 
                               background: #f44336; color: white; border: none; 
                               border-radius: 5px; cursor: pointer; margin-top: 10px; line-height: 20px;">
                    Schließen
                </button>
            </div>
        </div>
    `;

    // Overlay zum DOM hinzufügen
    document.body.appendChild(overlay);

    // Event-Listener für Neustart-Button
    document.getElementById('restart-button').addEventListener('click', () => {
        document.body.removeChild(overlay);
        location.reload();
    });

    // Event-Listener für Schließen-Button
    document.getElementById('close-analysis').addEventListener('click', () => {
        const analysisSection = document.getElementById('analysis-section');
        if (analysisSection) {
            analysisSection.parentNode.removeChild(analysisSection);
        }
    });

    // ######## SPEICHER-FUNKTIONALITÄT ########
    document.getElementById('save-button').addEventListener('click', () => {
        if (analysis) {
            try {
                const bom = '\uFEFF';
                const dataWithBOM = bom + analysis;
                const blob = new Blob([dataWithBOM], {
                    type: "text/plain;charset=utf-8"
                });
                
                const downloadUrl = URL.createObjectURL(blob);
                const tempLink = document.createElement('a');
                tempLink.href = downloadUrl;
                tempLink.download = 'Ergebnis.txt';
                tempLink.style.display = 'none';
                
                document.body.appendChild(tempLink);
                tempLink.click();
                setTimeout(() => {
                    document.body.removeChild(tempLink);
                    URL.revokeObjectURL(downloadUrl);
                }, 100);

            } catch (error) {
                console.error('Fehler beim Speichern:', error);
            }
        }
    });
}




document.querySelectorAll('.human-area [data-label*="Ablage"]').forEach(target => {
    target.addEventListener('touchstart', (event) => {
        const discardPileIndex = Array.from(target.parentElement.children).indexOf(target);
        handleLongPress(event, discardPileIndex, 'human');
    });
    target.addEventListener('touchend', handleRelease);
    target.addEventListener('mousedown', (event) => {
        const discardPileIndex = Array.from(target.parentElement.children).indexOf(target);
        handleLongPress(event, discardPileIndex, 'human');
    });
    target.addEventListener('mouseup', handleRelease);
});


document.querySelectorAll('.opponent-area [data-label*="Ablage"]').forEach(target => {
    target.addEventListener('touchstart', (event) => {
        let discardPileIndex = Array.from(target.parentElement.children).indexOf(target);
        // Bei opponent-area ist das erste Kind der Stock, daher 1 abziehen:
        discardPileIndex = discardPileIndex - 1;
        handleLongPress(event, discardPileIndex, 'ai');
    });
    target.addEventListener('touchend', handleRelease);
    target.addEventListener('mousedown', (event) => {
        let discardPileIndex = Array.from(target.parentElement.children).indexOf(target);
        discardPileIndex = discardPileIndex - 1;
        handleLongPress(event, discardPileIndex, 'ai');
    });
    target.addEventListener('mouseup', handleRelease);
});


  /**
     * adjustLayoutForPortrait()
     *
     * Diese Funktion passt das Layout so an, dass der Spielcontainer (".game-container")
     * immer vollständig im sichtbaren Bereich erscheint, auch auf kleineren Geräten.
     *
     * Ansatz:
     * - Wir definieren eine Design-Höhe (desiredHeight) des Containers (diese sollte alle Kartenreihen enthalten).
     * - Ist die aktuelle Fensterhöhe (window.innerHeight) kleiner als desiredHeight,
     *   wird der Container per CSS transform skaliert, sodass seine gesamte Höhe in den sichtbaren Bereich passt.
     * - Der Container wird oben am Viewport positioniert (position: absolute; top: 0),
     *   sodass die obere Kartenreihe immer sichtbar bleibt. Da die Skalierung den gesamten Container anpasst, 
     *   wird auch die untere Reihe vollständig angezeigt.
     */
    function adjustLayoutForPortrait() {
      // Design-Höhe des Containers (diese Höhe entspricht der idealen Darstellung des Spiels)
      const desiredHeight = 600; // Diese Höhe kannst du nach Bedarf anpassen.
      
      // Auswahl des Spielcontainers
      const gameContainer = document.querySelector('.game-container');
      if (!gameContainer) return;
      
      // Ermittle die aktuelle Fensterhöhe
      const currentHeight = window.innerHeight;
      
      // Prüfe, ob das Gerät im Hochformat ist (Höhe > Breite)
      if(currentHeight > window.innerWidth) {
        // Berechne den Skalierungsfaktor: Wird der Container nur verkleinert, aber nicht vergrößert.
        const scaleFactor = Math.min(1, currentHeight / desiredHeight);
        
        // Setze den Transformationsursprung auf den oberen Rand, damit der Container von oben startet.
        gameContainer.style.transformOrigin = 'top center';
        
        // Wende den Skalierungsfaktor an und behalte die horizontale Zentrierung (translateX(-50%))
        gameContainer.style.transform = `translateX(-50%) scale(${scaleFactor})`;
      } else {
        // Im Querformat: Entferne Skalierung
        gameContainer.style.transform = 'translateX(-50%)';
      }
    }
    
    // Aktualisiere das Layout bei Fenstergrößenänderungen und Orientierungswechseln.
    window.addEventListener('resize', adjustLayoutForPortrait);
    window.addEventListener('orientationchange', adjustLayoutForPortrait);
    
    // Rufe die Funktion initial auf.
    adjustLayoutForPortrait();



// 
// Unabhängige Funktion zur Beobachtung und Auswertung von Spielen
// Sammelt Daten im Local Storage und gibt Analyse für das Gewinnfenster zurück
// Neu: Fügt Debug-Informationen hinzu, um Schwächen der KI zu identifizieren
// Anpassbar: 
// - Anzahl Spiele (aktuell 10, änderbar in maxGames)
// - Beobachtungsdaten (füge weitere Felder in observations hinzu, z. B. discardPileIndex)
// - Debug-Informationen (passe die Logs an, um spezifische Daten zu erfassen)
//
function trackGameObservations(eventType, data) {
    let storedData = JSON.parse(localStorage.getItem('skipbo_observations')) || { games: [], count: 0 };
    const maxGames = 10;

    let observations = { gameId: currentGameId };
switch (eventType) {
        // NEUER CASE FÜR DISCARD-STRATEGIE #############################
        case 'discardStrategy':
            observations.type = 'discardStrategy';
            observations.cardValue = data.cardValue;
            observations.dangerous = data.wasDangerous;
            observations.sequenceValue = data.createdSequence;
            observations.timestamp = Date.now();
            break;

        // NEUER CASE FÜR JOKER-STRATEGIE
        case 'jokerStrategicUse':
            observations.type = 'jokerStrategicUse';
            observations.jokerValue = data.jokerValue;
            observations.usedForStock = data.usedForStock;
            observations.buildPile = data.buildPileIndex;
            observations.timestamp = Date.now();
            break;

        case 'opponentBlock':
            observations.type = 'opponentBlock';
            observations.blockedValue = data.blockedValue;
            observations.kiStockSize = Game.players.ai.stock.length;
            observations.timestamp = Date.now();
            break;

        case 'opponentDiscard':
            observations.type = 'opponentDiscard';
            observations.cardValue = data.cardValue;
            observations.opponentStockSize = Game.players.human.stock.length;
            observations.kiNextNeeded = calculateKINextNeeded();
            observations.timestamp = Date.now();
            break;

        case 'kiMove':
            observations.type = 'kiMove';
            observations.sourceType = data.sourceType;
            observations.cardValue = data.cardValue;
            observations.isJoker = data.cardType === 'joker';
            observations.buildPileIndex = data.buildPileIndex;
            observations.stockSize = Game.players.ai.stock.length;
            observations.timestamp = Date.now();
            observations.helpedOpponent = Game.players.human.stock.slice(-1)[0]?.value === data.cardValue + 1 ||
                                          Game.players.human.discards.some(p => p[p.length - 1]?.value === data.cardValue + 1);


           if (observations.isJoker) {
                debugInfo.push(`📌48★Joker gelegt auf Bau🗑️ ${observations.buildPileIndex + 1} (Score: ${data.score})`);
            }
            if (observations.helpedOpponent) {
                debugInfo.push(`Gegnerhilfe: KI legte ${observations.cardValue}, Gegner könnte ${observations.cardValue + 1} nutzen`);
            }
            break;

        case 'missedStock':
            observations.type = 'missedStock';
            observations.stockCardValue = data.stockCardValue;
            observations.timestamp = Date.now();
if (nagel_deburg.nagel_45) {
            debugInfo.push(`Verpasster Stockzug: Stockkarte ${data.stockCardValue} hätte gelegt werden können`);
}
            break;

        case 'gameEnd':
            observations.type = 'gameEnd';
            observations.winner = data.winner;
            observations.loserStockSize = data.loserStockSize;
            observations.timestamp = Date.now();
            storedData.games.push(observations);
            storedData.count++;
            break;

        default:
            return null;
    }

    if (eventType !== 'gameEnd') {
        storedData.games.push(observations);
    }

    localStorage.setItem('skipbo_observations', JSON.stringify(storedData));

    if (eventType === 'gameEnd') {
        const currentGame = storedData.games.filter(g => g.gameId === currentGameId);
        const currentAnalysis = generateCurrentGameAnalysis(currentGame);
        const overallAnalysis = generateOverallAnalysis(storedData.games);
        const debugSection = generateDebugInfo();
        if (storedData.count >= maxGames) {
            localStorage.setItem('skipbo_observations', JSON.stringify({ games: [], count: 0 }));
        }
        currentGameId = Date.now();
        debugInfo = [];
        return `${currentAnalysis}\n\n${overallAnalysis}\n\n${debugSection}`;
    }
    
    return null;
}

// 
// Hilfsfunktion: Berechnet, welche Werte die KI als nächstes braucht
// Kann angepasst werden, um mehr Baustapel oder Präzision zu berücksichtigen
// z. B. nur aktive Baustapel prüfen oder Gewichtung einführen
//
function calculateKINextNeeded() {
    return Game.buildPiles.map(pile => 
        pile.length === 0 ? 1 : pile[pile.length - 1].type === 'joker' 
            ? pile.length + 1 
            : pile[pile.length - 1].value + 1
    );
}


// ====================
// KI-ANALYSE FUNKTIONEN Hilfsfunktion:
// ====================

/**
 * Prognostiziert die nächste Stock-Karte des Gegners
 */
function predictEnemyStock(opponent) {
  try {
    const visible = [
      ...Game.players[opponent].discards.flat(),
      ...Game.buildPiles.flat(),
      ...Game.players[opponent].hand
    ].filter(c => c).map(c => c.type === 'joker' ? 'joker' : c.value);

    const total = 144 - visible.length;
    const probs = Object.entries(Game.tracking.deckComposition).map(([k, v]) => ({
      value: k,
      prob: (v - visible.filter(x => x == k).length) / total
    }));

    const best = probs.reduce((a, b) => a.prob > b.prob ? a : b);
    return {
      nextExpected: best.value === 'joker' ? null : parseInt(best.value),
      confidence: best.prob
    };
  } catch {
    return { nextExpected: 1, confidence: 0.5 }; // * 🟢 ("Nagel36")
  }
}


/**
 * Erkennt numerische Serien in Discards
 */
function detectConsecutiveDiscards(player) {
  const values = Game.tracking.discardHistory[player].values
    .filter(v => v !== 'joker' && typeof v === 'number');
  
  const series = [];
  for(let i = 0; i < values.length - 2; i++) {
    if(values[i+1] === values[i]+1 && values[i+2] === values[i]+2) {
      series.push(values[i]+1);
    }
  }
  return [...new Set(series)];
}


/**
 * Dynamische Prioritätenberechnung
 */
function calculateDynamicPriorities() {
  const phase = 1 - (Game.drawPile.length / 144);
  const enemyStock = Game.players.human.stock.slice(-1)[0]?.value || 1;
  
  return {
    stockAttack: Math.min(1.5, (12 - enemyStock)/10 * phase),
    seriesDisrupt: 0.4 + (Game.tracking.discardHistory.human.values.length * 0.03),
    riskTaking: phase < 0.3 ? 0.8 : phase < 0.7 ? 1.0 : 1.3
  };
}


// 
// Generiert die Auswertung aus gesammelten Daten
// Anpassbar: Ändere den Text oder die Statistiken nach Bedarf
// z. B. mehr Details wie durchschnittliche Stockgröße hinzufügen
//
function generateAnalysis(games) {
    let analysis = "Skip-Bo KI-Auswertung (5 Spiele):\n\n";
    
    // Gegnerblockaden zählen
    const blocks = games.filter(g => g.type === 'opponentDiscard' && g.kiNextNeeded.includes(g.cardValue)).length;
    analysis += `Gegnerblockaden: ${blocks} Mal hat der Gegner eine benötigte Karte gelegt.\n`;
    
    // Joker-Nutzung
    const jokerUses = games.filter(g => g.type === 'kiMove' && g.isJoker);
    const earlyJoker = jokerUses.filter(g => g.buildPileIndex < 2).length;
    analysis += `Joker-Nutzung: ${jokerUses.length} Mal eingesetzt, davon ${earlyJoker} auf niedrigen Stapeln (< 2).\n`;
    
    // Stockabbau
    const stockMoves = games.filter(g => g.type === 'kiMove' && g.sourceType === 'stock').length;
    analysis += `Stockabbau: ${stockMoves} Stockkarten erfolgreich gelegt.\n`;
    
    // Spielergebnisse
    const wins = games.filter(g => g.type === 'gameEnd' && g.winner === 'KI').length;
    analysis += `Spiele gewonnen: ${wins} von 5.\n`;
    
    return analysis;
}


// 
// Neu: Generiert die Auswertung für das aktuelle Spiel
// Anpassbar: Ändere den Text oder füge weitere Statistiken hinzu
// z. B. Anzahl KI-Züge oder Gegneraktionen im aktuellen Spiel
//
function generateCurrentGameAnalysis(currentGame) {
    let analysis = "Auswertung des aktuellen Spiels:\n\n";
    
    // Gegnerblockaden im aktuellen Spiel
    const blocks = currentGame.filter(g => g.type === 'opponentDiscard' && g.kiNextNeeded.includes(g.cardValue)).length;
    analysis += `Gegnerblockaden: ${blocks} Mal hat der Gegner eine benötigte Karte gelegt.\n`;
    
    // Joker-Nutzung im aktuellen Spiel
    const jokerUses = currentGame.filter(g => g.type === 'kiMove' && g.isJoker).length;
    const earlyJoker = currentGame.filter(g => g.type === 'kiMove' && g.isJoker && g.buildPileIndex < 2).length;
    analysis += `Joker-Nutzung: ${jokerUses} Mal eingesetzt, davon ${earlyJoker} auf niedrigen Stapeln (< 2).\n`;
    
    // Stockabbau im aktuellen Spiel
    const stockMoves = currentGame.filter(g => g.type === 'kiMove' && g.sourceType === 'stock').length;
    analysis += `Stockabbau: ${stockMoves} Stockkarten erfolgreich gelegt.\n`;
    
    // Verpasste Stockzüge
    const missedStock = currentGame.filter(g => g.type === 'missedStock').length;
    analysis += `Verpasste Stockzüge: ${missedStock} Mal hätte eine Stockkarte gelegt werden können.\n`;
    
    // Gegnerhilfe
    const helpedOpponent = currentGame.filter(g => g.type === 'kiMove' && g.helpedOpponent).length;
    analysis += `Gegnerhilfe: ${helpedOpponent} Mal hat die KI dem Gegner geholfen.\n`;
    
    // Spielergebnis
    const gameEnd = currentGame.find(g => g.type === 'gameEnd');
    analysis += `Ergebnis: ${gameEnd.winner} hat gewonnen, Verlierer hatte ${gameEnd.loserStockSize} Stockkarten.\n`;
    
    return analysis;
}

// 
// Generiert die Gesamtbewertung aus allen gesammelten Daten
// Anpassbar: Ändere den Text oder die Statistiken nach Bedarf
// z. B. Durchschnittswerte oder detailliertere Statistiken hinzufügen
//
function generateOverallAnalysis(games) {
    let analysis = "Gesamtbewertung (bisherige Spiele):\n\n";
    
    // Gegnerblockaden zählen
    const blocks = games.filter(g => g.type === 'opponentDiscard' && g.kiNextNeeded.includes(g.cardValue)).length;
    analysis += `Gegnerblockaden: ${blocks} Mal hat der Gegner eine benötigte Karte gelegt.\n`;
    
    // Joker-Nutzung
    const jokerUses = games.filter(g => g.type === 'kiMove' && g.isJoker).length;
    const earlyJoker = games.filter(g => g.type === 'kiMove' && g.isJoker && g.buildPileIndex < 2).length;
    analysis += `Joker-Nutzung: ${jokerUses} Mal eingesetzt, davon ${earlyJoker} auf niedrigen Stapeln (< 2).\n`;
    
    // Stockabbau
    const stockMoves = games.filter(g => g.type === 'kiMove' && g.sourceType === 'stock').length;
    analysis += `Stockabbau: ${stockMoves} Stockkarten erfolgreich gelegt.\n`;
    
    // Verpasste Stockzüge
    const missedStock = games.filter(g => g.type === 'missedStock').length;
    analysis += `Verpasste Stockzüge: ${missedStock} Mal hätte eine Stockkarte gelegt werden können.\n`;
    
    // Gegnerhilfe
    const helpedOpponent = games.filter(g => g.type === 'kiMove' && g.helpedOpponent).length;
    analysis += `Gegnerhilfe: ${helpedOpponent} Mal hat die KI dem Gegner geholfen.\n`;
    
    // Spielergebnisse
    const totalGames = games.filter(g => g.type === 'gameEnd').length;
    const wins = games.filter(g => g.type === 'gameEnd' && g.winner === 'KI').length;
    analysis += `Spiele gewonnen: ${wins} von ${totalGames} (max. 10).\n`;
    
    return analysis;
}



// 
// Neu: Generiert die Debug-Informationen für das aktuelle Spiel
// Zeigt Details zu Joker-Einsätzen, Gegnerhilfe und verpassten Stockzügen
// Anpassbar: Füge weitere Debug-Informationen hinzu, z. B. Zugreihenfolge oder Alternativen
//
function generateDebugInfo() {
    let debugSection = "Debug-Informationen (aktuelles Spiel):\n\n";
    if (debugInfo.length === 0) {
        debugSection += "Keine spezifischen Debug-Informationen verfügbar.\n";
    } else {
        debugInfo.forEach(info => {
            debugSection += `- ${info}\n`;
        });
    }
    return debugSection;
}

// 
// Öffnet ein Extrafenster mit kopierbarem Text im Vordergrund
// Anpassbar: Ändere Größe (width, height) oder Stil des Fensters
// z. B. width auf 500 oder height auf 400 für größeres Fenster
//
function showAnalysisWindow(analysis) {
    const win = window.open('', 'Skip-Bo Analyse', 'width=400,height=400');
    win.document.write(`
        <html>
        <body style="font-family: Arial; padding: 10px;">
            <h2> Version 4.5.2 -Auswertung- </h2>
            <textarea style="width: 100%; height: 300px; font-size: 14px;">${analysis}</textarea>
            <p>Kopiere den Text und sende ihn an den Entwickler!</p>
        </body>
        </html>
    `);
    win.document.close();
    win.focus(); // Stellt sicher, dass das Fenster im Vordergrund ist
} 

// NaN. nagel_27
drawCardsUntilFive('ai'); // zusätzlich eingefügt dddd

</script>

</body>
</html>


